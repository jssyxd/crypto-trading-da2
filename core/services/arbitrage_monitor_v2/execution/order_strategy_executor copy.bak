from __future__ import annotations

"""
è®¢å•ç­–ç•¥æ‰§è¡Œå™¨æ¨¡å—
------------------
è´Ÿè´£æ‰¿æ¥ `ArbitrageExecutor` ä¸­æ‰€æœ‰ä¸â€œä¸‹å•æ¨¡å¼é€‰æ‹© + æ‰§è¡Œæµç¨‹â€æœ‰å…³çš„çº¯é€»è¾‘ï¼š
- è§£ææ‰§è¡Œè®¡åˆ’ï¼ˆé™ä»·/å¸‚ä»·/åŒé™ä»·/æ‰¹é‡WSï¼‰
- è°ƒåº¦å„æ‰§è¡Œæ¨¡å¼å¹¶å¤„ç†éƒ¨åˆ†æˆäº¤ã€fallbackã€å¸‚ä»·è¡¥å•
- ä¿æŒåŸæœ‰æ—¥å¿—ä¸å¼‚å¸¸æ ¼å¼ï¼Œç¡®ä¿å¤–å±‚è¡Œä¸ºä¸€è‡´

æ­¤æ¨¡å—ä¸åšä¾èµ–æ³¨å…¥æˆ–çŠ¶æ€ç®¡ç†ï¼Œæ‰€æœ‰å¤–éƒ¨ä¾èµ–é€šè¿‡ `executor` ä¼ å…¥ï¼Œåšåˆ°â€œå¯è¯»ã€å¯å¤ç”¨ã€ä¸æ”¹åŠŸèƒ½â€ã€‚
"""

import asyncio
import time
from decimal import Decimal, ROUND_DOWN, ROUND_UP, InvalidOperation
import logging
from typing import Any, Dict, Optional, Type, TYPE_CHECKING, Tuple, List

from core.adapters.exchanges.interface import ExchangeInterface
from core.adapters.exchanges.models import OrderData, OrderSide
from core.adapters.exchanges.utils.setup_logging import LoggingConfig

from ..risk_control.network_state import notify_network_recovered

if TYPE_CHECKING:
    from .arbitrage_executor import (
        ArbitrageExecutor,
        ExecutionRequest,
        ExecutionResult,
        ReduceOnlyRestrictionError,
    )


logger = LoggingConfig.setup_logger(
    name=__name__,
    log_file='arbitrage_executor.log',
    console_formatter=None,
    file_formatter='detailed',
    level=logging.INFO
)
logger.propagate = False


class OrderStrategyExecutor:
    """å°è£…ä¸‹å•æ¨¡å¼é€‰æ‹©ä¸æ‰§è¡Œé€»è¾‘ï¼Œé™ä½ ArbitrageExecutor ä½“ç§¯ã€‚"""

    def __init__(
        self,
        executor: "ArbitrageExecutor",
        execution_result_cls: Type["ExecutionResult"],
        reduce_only_exception_cls: Type["ReduceOnlyRestrictionError"],
    ) -> None:
        self.executor = executor
        self.ExecutionResult = execution_result_cls
        self.ReduceOnlyRestrictionError = reduce_only_exception_cls

    def _mark_symbol_waiting(self, request: Optional["ExecutionRequest"], reason: str) -> None:
        """é€šçŸ¥æ‰§è¡Œå™¨å°†ç¬¦å·æ ‡è®°ä¸ºç­‰å¾…çŠ¶æ€ã€‚"""
        if not request:
            return
        self.executor._mark_symbol_waiting(request, reason)

    def _mark_manual_intervention(self, request: Optional["ExecutionRequest"], reason_suffix: str) -> None:
        """
        å°†å¥—åˆ©å¯¹æ ‡è®°ä¸ºéœ€è¦äººå·¥ä»‹å…¥ï¼Œç»ˆç«¯çŠ¶æ€æ ä¼šæ˜¾ç¤ºå¯¹åº”æç¤ºã€‚
        """
        if not request:
            return
        symbol = getattr(request, "symbol", None)
        state_manager = getattr(self.executor, "symbol_state_manager", None)
        if not symbol or not state_manager:
            return
        reason = f"éœ€äººå·¥ä»‹å…¥ï¼š{reason_suffix}".strip()
        state_manager.defer(
            symbol=symbol,
            reason=reason,
            grid_level=getattr(request, "grid_level", None),
            exchange_buy=getattr(request, "exchange_buy", None),
            exchange_sell=getattr(request, "exchange_sell", None),
        )
    
    def _apply_second_leg_overrides(
        self,
        request: "ExecutionRequest",
        plan: Dict[str, Any],
    ) -> Dict[str, Any]:
        """
        é’ˆå¯¹é™ä»·+å¸‚ä»·æ¨¡å¼çš„ç¬¬äºŒè…¿åšé¢å¤–é…ç½®è¦†å†™ï¼Œ
        ä¾‹å¦‚ lighter è®¾ç½® force_limit_when_second_leg æ—¶æ”¹ç”¨æ¿€è¿›é™ä»·ã€‚
        """
        if plan.get("mode") != "limit_market":
            return plan
        if plan.get("second_order_mode") != "market":
            return plan
        
        second_exchange = plan.get("second_exchange")
        if not second_exchange:
            return plan
        
        second_symbol = (
            (request.buy_symbol or request.symbol)
            if plan.get("second_is_buy")
            else (request.sell_symbol or request.symbol)
        )
        exchange_config = self.executor._get_exchange_mode_config(
            second_exchange,
            second_symbol,
        )
        if exchange_config and getattr(exchange_config, "force_limit_when_second_leg", False):
            updated_plan = dict(plan)
            updated_plan["second_order_mode"] = "limit"
            logger.info(
                f"[æ‰§è¡Œè®¡åˆ’] {second_exchange} å¯ç”¨ force_limit_when_second_legï¼Œ"
                "ç¬¬äºŒè…¿æ”¹ä¸ºæ¿€è¿›é™ä»·é¡ºåºæ‰§è¡Œã€‚"
            )
            return updated_plan
        return plan

    async def _wait_fill_after_cancel_failure(
        self,
        order: Optional[OrderData],
        adapter: ExchangeInterface,
        symbol: str,
        target_quantity: Decimal,
        exchange_tag: str,
        *,
        wait_seconds: float = 2.0,
        interval_seconds: float = 0.2,
    ) -> Optional[Decimal]:
        """
        æ’¤å•å¤±è´¥åé¢å¤–ç­‰å¾… WebSocket/REST æ›´æ–°ï¼Œä»¥æ•æ‰â€œåˆšæˆäº¤ä½†å°šæœªæ¨é€â€çš„æƒ…å†µã€‚
        è¿”å›æ£€æµ‹åˆ°çš„æœ€æ–°æˆäº¤é‡ï¼ˆè‹¥æ— æ›´æ–°åˆ™è¿”å› Noneï¼‰ã€‚
        """
        if not order or not getattr(order, "id", None):
            return None

        epsilon = Decimal("0.00000001")
        interval = max(0.05, interval_seconds)
        remaining = max(0.0, wait_seconds)

        refreshed_total = await self._resolve_filled_quantity(
            order=order,
            adapter=adapter,
            symbol=symbol,
            reported_filled=None,
        )
        best_fill = self.executor._to_decimal_value(refreshed_total or Decimal("0"))
        if best_fill + epsilon >= target_quantity:
            return best_fill

        loop = asyncio.get_running_loop()
        deadline = loop.time() + remaining
        while loop.time() < deadline:
            await asyncio.sleep(interval)
            refreshed_total = await self._resolve_filled_quantity(
                order=order,
                adapter=adapter,
                symbol=symbol,
                reported_filled=None,
            )
            current_fill = self.executor._to_decimal_value(refreshed_total or Decimal("0"))
            if current_fill > best_fill + epsilon:
                logger.info(
                    f"â³ [å¥—åˆ©æ‰§è¡Œ] [{exchange_tag}] æ’¤å•å¤±è´¥åæ£€æµ‹åˆ°æ–°å¢æˆäº¤ {current_fill}"
                )
            best_fill = max(best_fill, current_fill)
            if best_fill + epsilon >= target_quantity:
                return best_fill

        return best_fill if best_fill > Decimal("0") else None

    async def _retry_limit_submission(
        self,
        *,
        adapter: ExchangeInterface,
        symbol: str,
        price: Decimal,
        quantity: Decimal,
        is_buy: bool,
        absolute_offset: Optional[Decimal],
        request: "ExecutionRequest",
        exchange_name: str,
    ) -> Optional[OrderData]:
        logger.warning(
            "ğŸ” [å¥—åˆ©æ‰§è¡Œ] %s é™ä»·è®¢å•æäº¤å¤±è´¥ï¼Œå¯åŠ¨å¤±è´¥è…¿é‡è¯•ï¼ˆæ–¹å‘=%sï¼Œæ•°é‡=%sï¼‰",
            exchange_name,
            "ä¹°å…¥" if is_buy else "å–å‡º",
            quantity,
        )
        refreshed_price = self.executor._get_live_market_price(
            exchange_name,
            symbol,
            is_buy,
        )
        effective_price = refreshed_price or price
        if refreshed_price and refreshed_price != price:
            logger.info(
                f"[å¥—åˆ©æ‰§è¡Œ] [{self.executor._format_exchange_tag(exchange_name)}] "
                f"é™ä»·é‡è¯•ä½¿ç”¨æœ€æ–°ç›˜å£ä»·: {effective_price} (åŸä»·={price})"
            )
        return await self.executor._place_limit_order(
            adapter,
            symbol,
            effective_price,
            quantity,
            is_buy=is_buy,
            absolute_offset=absolute_offset,
            request=request,
        )

    async def _handle_first_leg_min_qty_failure(
        self,
        *,
        request: "ExecutionRequest",
        execution_plan: Dict[str, Any],
        first_exchange: str,
        first_adapter: ExchangeInterface,
        first_symbol: str,
        accumulated_fill: Decimal,
        submit_quantity: Decimal,
        min_first_leg_qty: Decimal,
    ) -> "ExecutionResult":
        """
        å¤„ç†ç¬¬ä¸€è…¿é™ä»·å•å› å‰©ä½™æ•°é‡ä½äºæœ€å°ä¸‹å•é‡è€Œæ— æ³•æäº¤çš„åœºæ™¯ã€‚
        """
        executor = self.executor
        Result = self.ExecutionResult
        epsilon = Decimal("0.00000001")

        qty_text = f"{submit_quantity:.8f}"
        min_text = f"{min_first_leg_qty:.8f}"

        logger.error(
            f"âŒ [å¥—åˆ©æ‰§è¡Œ] [{executor._format_exchange_tag(first_exchange)}] "
            f"å‰©ä½™æ•°é‡ {qty_text} ä½äºæœ€å°ä¸‹å•é‡ {min_text}ï¼Œé™ä»·å•æäº¤å¤±è´¥ï¼Œè§¦å‘ç´§æ€¥å¹³ä»“æµç¨‹ã€‚"
        )

        close_success = True
        if accumulated_fill > epsilon:
            try:
                close_success = await executor._emergency_close_position(
                    exchange=first_exchange,
                    adapter=first_adapter,
                    symbol=first_symbol,
                    quantity=accumulated_fill,
                    is_buy_to_close=not execution_plan["first_is_buy"],
                    request=request,
                )
            except Exception as exc:
                logger.error(
                    f"âŒ [å¥—åˆ©æ‰§è¡Œ] [{executor._format_exchange_tag(first_exchange)}] "
                    f"ç´§æ€¥å¹³ä»“å¼‚å¸¸: {exc}",
                    exc_info=True,
                )
                close_success = False

        if close_success:
            logger.warning(
                f"âš ï¸ [å¥—åˆ©æ‰§è¡Œ] [{executor._format_exchange_tag(first_exchange)}] "
                "å·²æ’¤å›å·²æˆäº¤éƒ¨åˆ†ï¼Œç­‰å¾…é‡æ–°è°ƒæ•´æœ€å°ä¸‹å•é‡åå†å°è¯•ã€‚"
            )
        else:
            logger.error(
                f"ğŸš¨ [å¥—åˆ©æ‰§è¡Œ] [{executor._format_exchange_tag(first_exchange)}] "
                "ç´§æ€¥å¹³ä»“å¤±è´¥ï¼Œéœ€äººå·¥ä»‹å…¥å¤„ç†å‰©ä½™ä»“ä½ã€‚"
            )
            self._mark_manual_intervention(
                request,
                f"{first_exchange} æœ€å°ä¸‹å•é‡ {min_text}ï¼Œå½“å‰å‰©ä½™ {qty_text}",
            )

        return self._result_failure(
            request,
            f"{first_exchange} é™ä»·å•å‰©ä½™æ•°é‡ä½äºæœ€å°ä¸‹å•é‡ï¼Œå·²åœæ­¢æœ¬æ¬¡æ‰§è¡Œå¹¶ç­‰å¾…äººå·¥ä»‹å…¥",
            failure_code="limit_min_qty_violation",
        )

    async def _retry_market_submission(
        self,
        *,
        adapter: ExchangeInterface,
        symbol: str,
        quantity: Decimal,
        is_buy: bool,
        reduce_only: bool,
        request: "ExecutionRequest",
        exchange_name: str,
        slippage_override: Optional[Decimal] = None,
    ) -> Optional[OrderData]:
        logger.warning(
            "ğŸ” [å¥—åˆ©æ‰§è¡Œ] %s å¸‚ä»·è®¢å•æäº¤å¤±è´¥ï¼Œå¯åŠ¨å¤±è´¥è…¿é‡è¯•ï¼ˆæ–¹å‘=%sï¼Œæ•°é‡=%sï¼‰",
            exchange_name,
            "ä¹°å…¥" if is_buy else "å–å‡º",
            quantity,
        )
        return await self.executor._place_market_order(
            adapter,
            symbol,
            quantity,
            is_buy=is_buy,
            reduce_only=reduce_only,
            request=request,
            slippage_override=slippage_override,
        )

    async def _place_aggressive_limit_retry_order(
        self,
        *,
        adapter: ExchangeInterface,
        symbol: str,
        quantity: Decimal,
        is_buy: bool,
        request: Optional["ExecutionRequest"],
        exchange_name: str,
        slippage_pct: Optional[Decimal],
        base_slippage: Optional[Decimal],
    ) -> Optional[OrderData]:
        """å¸‚ä»·å¤šæ¬¡å¤±è´¥åï¼Œæ”¹ç”¨æœ€æ–°ç›˜å£ä»· + åŠ å€åç§»çš„æ¿€è¿›é™ä»·å•åƒå•ã€‚"""
        if not request:
            return None

        executor = self.executor

        base_price_raw = request.price_buy if is_buy else request.price_sell
        fallback_price_raw = request.price_sell if is_buy else request.price_buy

        live_price = executor._get_live_market_price(exchange_name, symbol, is_buy)
        if live_price is not None:
            price_decimal = live_price
        else:
            price_source = base_price_raw if base_price_raw not in (None, 0) else fallback_price_raw
            price_decimal = executor._to_decimal_value(price_source or Decimal("0"))

        if price_decimal <= Decimal("0"):
            return None

        multiplier = Decimal("2")

        absolute_offset: Optional[Decimal] = None
        raw_absolute_offset = None
        if request:
            raw_absolute_offset = (
                request.limit_price_offset_buy if is_buy else request.limit_price_offset_sell
            )
        if raw_absolute_offset is not None:
            absolute_offset = executor._to_decimal_value(raw_absolute_offset)
            if absolute_offset <= Decimal("0"):
                absolute_offset = None
        if absolute_offset is not None:
            absolute_offset *= multiplier

        offset_pct = slippage_pct or base_slippage or Decimal("0.001")
        if offset_pct <= Decimal("0"):
            offset_pct = Decimal("0.001")
        offset_pct = executor._to_decimal_value(offset_pct) * multiplier

        if is_buy:
            if absolute_offset:
                target_price = price_decimal + absolute_offset
            else:
                target_price = price_decimal * (Decimal("1") + offset_pct)
        else:
            if absolute_offset:
                target_price = price_decimal - absolute_offset
            else:
                target_price = price_decimal * (Decimal("1") - offset_pct)
            if target_price <= Decimal("0"):
                target_price = price_decimal * Decimal("0.999")

        step = executor._infer_price_step(price_decimal)
        if step > Decimal("0"):
            rounding_mode = ROUND_UP if is_buy else ROUND_DOWN
            target_price = target_price.quantize(step, rounding=rounding_mode)

        exchange_tag = executor._format_exchange_tag(exchange_name)
        leg_label = "ä¹°è…¿" if is_buy else "å–è…¿"
        offset_hint = (
            f"{absolute_offset} (abs)"
            if absolute_offset
            else f"{float((offset_pct * Decimal('100'))):.4f}%"
        )
        logger.info(
            f"[å¥—åˆ©æ‰§è¡Œ] [{exchange_tag}] æ¿€è¿›é™ä»·è¡¥ä»“[{leg_label}]: åŸºå‡†ä»·={price_decimal}, ç›®æ ‡ä»·={target_price}, åç§»={offset_hint}"
        )

        return await executor._place_limit_order(
            adapter=adapter,
            symbol=symbol,
            price=price_decimal,
            quantity=quantity,
            is_buy=is_buy,
            absolute_offset=None,
            request=request,
            override_price=target_price,
        )

    async def _confirm_market_fill_with_retries(
        self,
        *,
        initial_order: Optional[OrderData],
        adapter: ExchangeInterface,
        symbol: str,
        quantity: Decimal,
        is_buy: bool,
        reduce_only: bool,
        request: Optional["ExecutionRequest"],
        exchange_name: str,
        allow_resubmit: bool = True,
        max_attempts: Optional[int] = None,
        enable_internal_aggressive_retry: bool = True,
    ) -> Tuple[Optional[OrderData], Decimal]:
        """
        ç­‰å¾…å¸‚ä»·è®¢å•æˆäº¤ï¼Œå¿…è¦æ—¶é‡æ–°æäº¤ï¼Œé¿å…é•¿æœŸæ— æˆäº¤é€ æˆå•è…¿é£é™©ã€‚
        enable_internal_aggressive_retry=False æ—¶ç¦ç”¨å†…éƒ¨æ¿€è¿›é™ä»·å…œåº•ï¼ˆä¾›åŒé™ä»·è¡¥ä»“è‡ªå®šä¹‰æµç¨‹ä½¿ç”¨ï¼‰ã€‚
        """
        executor = self.executor
        leg_label = "ä¹°è…¿" if is_buy else "å–è…¿"
        epsilon = Decimal("0.00000001")
        limit_timeout_cfg = getattr(
            executor.config.order_execution,
            "limit_order_timeout",
            60,
        ) or 60
        try:
            limit_timeout = max(1, int(limit_timeout_cfg))
        except (ValueError, TypeError):
            limit_timeout = 60
        lighter_market_timeout_cfg = getattr(
            executor.config.order_execution,
            "lighter_market_order_timeout",
            None,
        )
        lighter_market_timeout: Optional[int] = None
        if lighter_market_timeout_cfg not in (None, 0):
            try:
                lighter_market_timeout = max(1, int(lighter_market_timeout_cfg))
            except (ValueError, TypeError):
                lighter_market_timeout = None
        configured_attempt_limit = max_attempts or getattr(
            executor.config.order_execution,
            "max_retry_count",
            3,
        )
        if configured_attempt_limit != 1:
            logger.debug(
                "âš™ï¸ å¸‚ä»·è¡¥å•æœ€å¤§é‡è¯•æ¬¡æ•°é…ç½®=%sï¼Œä½†å½“å‰ç­–ç•¥å¼ºåˆ¶ä½¿ç”¨å•æ¬¡å°è¯•ã€‚",
                configured_attempt_limit,
            )
        # âš ï¸ éœ€æ±‚å˜æ›´ï¼šæ‰€æœ‰åœºæ™¯ä¸‹å¸‚ä»·ä»…å…è®¸ä¸€æ¬¡å°è¯•ï¼Œå¤±è´¥å³è¿›å…¥ä¸‹ä¸€æµç¨‹
        market_attempt_limit = 1
        market_attempts_used = 1 if initial_order is not None else 0
        current_order = initial_order
        current_is_market = True
        last_order = initial_order
        target_quantity = executor._to_decimal_value(quantity)
        base_slippage = executor._get_slippage_percent(request)
        last_slippage_override: Optional[Decimal] = base_slippage
        lighter_retry_mode = bool(exchange_name and exchange_name.lower() == "lighter")
        aggressive_limit_attempted = False

        while True:
            if current_order is None:
                if not allow_resubmit and not aggressive_limit_attempted:
                    break
                slippage_override = None
                if market_attempts_used < market_attempt_limit:
                    if base_slippage is not None:
                        multiplier = Decimal(2) ** (market_attempts_used)
                        slippage_override = base_slippage * multiplier
                        last_slippage_override = slippage_override
                    slip_hint = (
                        f"ï¼Œæ»‘ç‚¹={float(slippage_override * Decimal('100')):.4f}%"
                        if slippage_override is not None
                        else ""
                    )
                    logger.warning(
                        "â±ï¸ [å¥—åˆ©æ‰§è¡Œ] %s %s å¸‚ä»·è¡¥å•å°è¯•(%s/%s)%sï¼Œè‹¥å¤±è´¥å°†ç›´æ¥è¿›å…¥ä¸‹ä¸€æµç¨‹",
                        exchange_name,
                        leg_label,
                        market_attempts_used + 1,
                        market_attempt_limit,
                        slip_hint,
                    )
                    try:
                        current_order = await executor._place_market_order(
                            adapter,
                            symbol,
                            target_quantity,
                            is_buy=is_buy,
                            reduce_only=reduce_only,
                            request=request,
                            slippage_override=slippage_override,
                        )
                        current_is_market = True
                        market_attempts_used += 1
                    except self.ReduceOnlyRestrictionError:
                        raise

                    if not current_order:
                        current_order = await self._retry_market_submission(
                            adapter=adapter,
                            symbol=symbol,
                            quantity=target_quantity,
                            is_buy=is_buy,
                            reduce_only=reduce_only,
                            request=request,
                            exchange_name=exchange_name,
                            slippage_override=slippage_override,
                        )
                        current_is_market = True
                        if not current_order:
                            continue
                elif enable_internal_aggressive_retry and not aggressive_limit_attempted:
                    logger.warning(
                        "ğŸ” [å¥—åˆ©æ‰§è¡Œ] %s %s å¸‚ä»·è¡¥å•å¤šæ¬¡å¤±è´¥ï¼Œå°è¯•æ¿€è¿›é™ä»·åƒå•",
                        exchange_name,
                        leg_label,
                    )
                    current_order = await self._place_aggressive_limit_retry_order(
                        adapter=adapter,
                        symbol=symbol,
                        quantity=target_quantity,
                        is_buy=is_buy,
                        request=request,
                        exchange_name=exchange_name,
                        slippage_pct=last_slippage_override or base_slippage,
                        base_slippage=base_slippage,
                    )
                    aggressive_limit_attempted = True
                    current_is_market = False
                    if not current_order:
                        break
                else:
                    break

                last_order = current_order

            wait_timeout = (
                lighter_market_timeout
                if lighter_retry_mode and current_is_market and lighter_market_timeout
                else limit_timeout
            )
            filled = await executor.order_monitor.wait_for_order_fill(
                current_order,
                adapter,
                timeout=wait_timeout,
                is_market_order=current_is_market,
            )
            filled_decimal = executor._to_decimal_value(filled or Decimal("0"))
            if filled_decimal > epsilon:
                price_info = getattr(current_order, "average", None) or getattr(current_order, "price", None)
                price_text = (
                    f"{executor._to_decimal_value(price_info):f}"
                    if price_info is not None
                    else "--"
                )
                # ğŸ”„ åŒæ­¥è®¢å•å¯¹è±¡çš„æœ€æ–°æˆäº¤ä¿¡æ¯ï¼Œä¾¿äºåç»­ç»Ÿè®¡
                current_order.filled = filled_decimal
                normalized_amount = executor._to_decimal_value(
                    getattr(current_order, "amount", None) or filled_decimal
                )
                current_order.amount = normalized_amount
                current_order.remaining = max(normalized_amount - filled_decimal, Decimal("0"))
                price_decimal = executor._to_decimal_value(price_info) if price_info is not None else None
                if price_decimal is not None:
                    current_order.average = price_decimal
                    current_order.price = price_decimal
                    current_cost = executor._to_decimal_value(getattr(current_order, "cost", None))
                    if current_cost <= Decimal("0"):
                        current_order.cost = price_decimal * filled_decimal

                logger.info(
                    "âœ… [å¥—åˆ©æ‰§è¡Œ] %s %s å¸‚ä»·è¡¥å•æˆäº¤: å°è¯•#%s, æ•°é‡=%s, ä»·æ ¼=%s",
                    exchange_name,
                    leg_label,
                    market_attempts_used,
                    filled_decimal,
                    price_text,
                )
                return current_order, filled_decimal

            if executor._is_slippage_cancel(current_order):
                logger.error(
                    "âŒ [å¥—åˆ©æ‰§è¡Œ] %s %s å¸‚ä»·è¡¥å•å› æ»‘ç‚¹ä¿æŠ¤è¢«å–æ¶ˆ: order_id=%s",
                    exchange_name,
                    leg_label,
                    current_order.id if current_order else "-",
                )
                if aggressive_limit_attempted:
                    break
                current_order = None
                current_is_market = True
                continue

            logger.warning(
                "%s [å¥—åˆ©æ‰§è¡Œ] %s %s è¡¥å•æœªç¡®è®¤æˆäº¤: order_id=%s",
                "âš ï¸" if current_is_market else "âŒ",
                exchange_name,
                leg_label,
                current_order.id if current_order else "-",
            )
            if aggressive_limit_attempted:
                break
            current_order = None
            current_is_market = True

        return last_order, Decimal("0")

    def _result_failure(
        self,
        request: Optional["ExecutionRequest"],
        message: str,
        *,
        mark_waiting: bool = True,
        **kwargs: Any,
    ) -> "ExecutionResult":
        if mark_waiting:
            self._mark_symbol_waiting(request, message)
        return self.ExecutionResult(
            success=False,
            error_message=message,
            **kwargs,
        )

    def determine_execution_plan(self, request: "ExecutionRequest") -> Dict[str, Any]:
        executor = self.executor
        dual_limit_enabled = getattr(
            executor.config.order_execution,
            "enable_dual_limit_mode",
            False,
        )

        buy_exchange_config = executor._get_exchange_mode_config(
            request.exchange_buy,
            request.buy_symbol or request.symbol,
        )
        buy_mode = buy_exchange_config.order_mode if buy_exchange_config else "market"
        buy_priority = buy_exchange_config.priority if buy_exchange_config else 0

        sell_exchange_config = executor._get_exchange_mode_config(
            request.exchange_sell,
            request.sell_symbol or request.symbol,
        )
        sell_mode = sell_exchange_config.order_mode if sell_exchange_config else "market"
        sell_priority = sell_exchange_config.priority if sell_exchange_config else 0

        logger.debug(
            f"[æ‰§è¡Œè®¡åˆ’] {request.exchange_buy}(ä¹°å…¥): mode={buy_mode}, priority={buy_priority} | "
            f"{request.exchange_sell}(å–å‡º): mode={sell_mode}, priority={sell_priority}"
        )

        if buy_mode == "market" and sell_mode == "market":
            return self._apply_second_leg_overrides(
                request,
                {
                    "mode": "market_market",
                    "first_exchange": None,
                    "first_is_buy": None,
                    "first_order_mode": None,
                    "second_exchange": None,
                    "second_is_buy": None,
                    "second_order_mode": None,
                    "parallel": True,
                },
            )

        if buy_mode == "limit" and sell_mode == "limit":
            # ğŸ”¥ æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä¸€æ–¹å¯ç”¨äº† force_sequential_limit
            buy_force_sequential = getattr(buy_exchange_config, "force_sequential_limit", False) if buy_exchange_config else False
            sell_force_sequential = getattr(sell_exchange_config, "force_sequential_limit", False) if sell_exchange_config else False
            
            logger.debug(
                f"[æ‰§è¡Œè®¡åˆ’] åŒé™ä»·æ£€æŸ¥: {request.exchange_buy}(buy_force={buy_force_sequential}) | "
                f"{request.exchange_sell}(sell_force={sell_force_sequential})"
            )
            
            # å¦‚æœä»»ä¸€æ–¹å¯ç”¨äº†å¼ºåˆ¶é¡ºåºæ‰§è¡Œï¼Œé‡‡ç”¨ limit+market æ¨¡å¼
            if buy_force_sequential or sell_force_sequential:
                # ä¼˜å…ˆæ‰§è¡Œæ²¡æœ‰å¯ç”¨ force_sequential_limit çš„ä¸€æ–¹ï¼ˆè®©å®ƒå…ˆæŒ‚é™ä»·å•ï¼‰
                # å¯ç”¨ force_sequential_limit çš„ä¸€æ–¹åæ‰§è¡Œï¼ˆç”¨æ¿€è¿›é™ä»·å•åƒå•ï¼‰
                if buy_force_sequential and not sell_force_sequential:
                    # buyæ–¹å¼ºåˆ¶é¡ºåºï¼Œå…ˆæ‰§è¡Œsellï¼ˆé™ä»·ï¼‰ï¼Œå†æ‰§è¡Œbuyï¼ˆæ¿€è¿›é™ä»·åƒå•ï¼‰
                    first_exchange = request.exchange_sell
                    first_is_buy = False
                    second_exchange = request.exchange_buy
                    second_is_buy = True
                    logger.info(
                        f"[æ‰§è¡Œè®¡åˆ’] {request.exchange_buy} å¯ç”¨force_sequential_limitï¼Œ"
                        f"é‡‡ç”¨å…ˆé™ä»·({first_exchange})åæ¿€è¿›é™ä»·åƒå•({second_exchange})æ¨¡å¼"
                    )
                elif sell_force_sequential and not buy_force_sequential:
                    # sellæ–¹å¼ºåˆ¶é¡ºåºï¼Œå…ˆæ‰§è¡Œbuyï¼ˆé™ä»·ï¼‰ï¼Œå†æ‰§è¡Œsellï¼ˆæ¿€è¿›é™ä»·åƒå•ï¼‰
                    first_exchange = request.exchange_buy
                    first_is_buy = True
                    second_exchange = request.exchange_sell
                    second_is_buy = False
                    logger.info(
                        f"[æ‰§è¡Œè®¡åˆ’] {request.exchange_sell} å¯ç”¨force_sequential_limitï¼Œ"
                        f"é‡‡ç”¨å…ˆé™ä»·({first_exchange})åæ¿€è¿›é™ä»·åƒå•({second_exchange})æ¨¡å¼"
                    )
                else:
                    # åŒæ–¹éƒ½å¯ç”¨äº†å¼ºåˆ¶é¡ºåºï¼Œæ ¹æ®priorityå†³å®š
                    if buy_priority >= sell_priority:
                        first_exchange = request.exchange_buy
                        first_is_buy = True
                        second_exchange = request.exchange_sell
                        second_is_buy = False
                    else:
                        first_exchange = request.exchange_sell
                        first_is_buy = False
                        second_exchange = request.exchange_buy
                        second_is_buy = True
                    logger.info(
                        f"[æ‰§è¡Œè®¡åˆ’] åŒæ–¹å‡å¯ç”¨force_sequential_limitï¼Œ"
                        f"æ ¹æ®priorityé‡‡ç”¨å…ˆé™ä»·({first_exchange})åæ¿€è¿›é™ä»·åƒå•({second_exchange})æ¨¡å¼"
                    )
                
                return self._apply_second_leg_overrides(
                    request,
                    {
                        "mode": "limit_market",
                        "first_exchange": first_exchange,
                        "first_is_buy": first_is_buy,
                        "first_order_mode": "limit",
                        "second_exchange": second_exchange,
                        "second_is_buy": second_is_buy,
                        "second_order_mode": "limit",  # ğŸ”¥ ç¬¬äºŒè…¿ä¹Ÿæ˜¯limitï¼Œä½†ä¼šç”¨æ¿€è¿›ä»·æ ¼åç§»
                        "parallel": False,
                    },
                )
            
            # æ²¡æœ‰å¯ç”¨å¼ºåˆ¶é¡ºåºï¼Œèµ°åŸæœ‰çš„åŒé™ä»·æˆ–limit+marketé€»è¾‘
            if dual_limit_enabled:
                return {
                    "mode": "limit_limit",
                    "first_exchange": None,
                    "first_is_buy": None,
                    "first_order_mode": "limit",
                    "second_exchange": None,
                    "second_is_buy": None,
                    "second_order_mode": "limit",
                    "parallel": True,
                }
            if buy_priority >= sell_priority:
                first_exchange = request.exchange_buy
                first_is_buy = True
                second_exchange = request.exchange_sell
                second_is_buy = False
            else:
                first_exchange = request.exchange_sell
                first_is_buy = False
                second_exchange = request.exchange_buy
                second_is_buy = True

            logger.warning(
                f"[æ‰§è¡Œè®¡åˆ’] {request.exchange_buy}/{request.exchange_sell} å‡ä¸ºlimitï¼Œ"
                f"æ ¹æ®priorityè°ƒæ•´ä¸ºå…ˆé™ä»·({first_exchange})åå¸‚ä»·({second_exchange})"
            )

            return self._apply_second_leg_overrides(
                request,
                {
                    "mode": "limit_market",
                    "first_exchange": first_exchange,
                    "first_is_buy": first_is_buy,
                    "first_order_mode": "limit",
                    "second_exchange": second_exchange,
                    "second_is_buy": second_is_buy,
                    "second_order_mode": "market",
                    "parallel": False,
                },
            )

        if buy_mode == "limit":
            return self._apply_second_leg_overrides(
                request,
                {
                    "mode": "limit_market",
                    "first_exchange": request.exchange_buy,
                    "first_is_buy": True,
                    "first_order_mode": "limit",
                    "second_exchange": request.exchange_sell,
                    "second_is_buy": False,
                    "second_order_mode": "market",
                    "parallel": False,
                },
            )

        return self._apply_second_leg_overrides(
            request,
            {
                "mode": "limit_market",
                "first_exchange": request.exchange_sell,
                "first_is_buy": False,
                "first_order_mode": "limit",
                "second_exchange": request.exchange_buy,
                "second_is_buy": True,
                "second_order_mode": "market",
                "parallel": False,
            },
        )

    async def execute_limit_market_mode(
        self,
        request: "ExecutionRequest",
        execution_plan: Dict[str, Any],
    ) -> "ExecutionResult":
        executor = self.executor
        Result = self.ExecutionResult
        epsilon = Decimal("0.00000001")
        
        # ğŸ”¥ è·å–é™ä»·å•è¶…æ—¶é…ç½®
        limit_timeout_cfg = getattr(
            executor.config.order_execution,
            "limit_order_timeout",
            60,
        ) or 60
        try:
            limit_timeout = max(1, int(limit_timeout_cfg))
        except (ValueError, TypeError):
            limit_timeout = 60

        buy_adapter = executor.exchange_adapters.get(request.exchange_buy)
        sell_adapter = executor.exchange_adapters.get(request.exchange_sell)

        buy_symbol = request.buy_symbol or request.symbol
        sell_symbol = request.sell_symbol or request.symbol

        if not buy_adapter or not sell_adapter:
            return self._result_failure(
                request,
                f"äº¤æ˜“æ‰€é€‚é…å™¨ä¸å­˜åœ¨: {request.exchange_buy} æˆ– {request.exchange_sell}",
                mark_waiting=False,
            )

        try:
            first_adapter = buy_adapter if execution_plan["first_is_buy"] else sell_adapter
            second_adapter = sell_adapter if execution_plan["first_is_buy"] else buy_adapter
            first_exchange = execution_plan["first_exchange"]
            second_exchange = execution_plan["second_exchange"]
            first_tag = self.executor._format_exchange_tag(first_exchange)
            second_tag = self.executor._format_exchange_tag(second_exchange)
            first_price = request.price_buy if execution_plan["first_is_buy"] else request.price_sell
            first_offset = (
                request.limit_price_offset_buy
                if execution_plan["first_is_buy"]
                else request.limit_price_offset_sell
            )

            first_symbol = buy_symbol if execution_plan["first_is_buy"] else sell_symbol
            first_exchange_config = self.executor._get_exchange_mode_config(
                first_exchange,
                first_symbol,
            )
            first_uses_tick_precision = bool(
                getattr(first_exchange_config, "use_tick_precision", False)
            )
            first_absolute_offset = None if first_uses_tick_precision else first_offset
            requested_quantity = executor._to_decimal_value(request.quantity or Decimal('0'))
            if requested_quantity <= epsilon:
                return self._result_failure(
                    request,
                    f"é™ä»·è®¢å•æ•°é‡å¼‚å¸¸ ({first_exchange})",
                    mark_waiting=False,
                )

            # é¢„å–ç¬¬äºŒè…¿ä¸Šä¸‹æ–‡ï¼Œé¿å…å›è°ƒè·¯å¾„é‡å¤è®¡ç®—
            second_is_buy = execution_plan["second_is_buy"]
            second_symbol = buy_symbol if second_is_buy else sell_symbol
            second_exchange_config = self.executor._get_exchange_mode_config(
                second_exchange,
                second_symbol,
            )
            second_uses_tick_precision = bool(
                getattr(second_exchange_config, "use_tick_precision", False)
            )
            prefetched_second_ctx = {
                "symbol": second_symbol,
                "is_buy": second_is_buy,
                "tag": second_tag,
                "uses_tick_precision": second_uses_tick_precision,
            }

            min_second_leg_qty = executor._resolve_min_order_qty(request, second_exchange)
            min_first_leg_qty = executor._resolve_min_order_qty(request, first_exchange)
            accumulated_fill = Decimal("0")
            max_partial_attempts = max(
                1,
                getattr(executor.config.order_execution, "max_retry_count", 3),
            )
            limit_attempt = 0
            limit_order: Optional[OrderData] = None
            zero_fill_abort = False
            zero_fill_order_id: Optional[str] = None

            while accumulated_fill + epsilon < requested_quantity:
                if limit_attempt >= max_partial_attempts:
                    break
                limit_attempt += 1
                remaining_quantity = max(Decimal("0"), requested_quantity - accumulated_fill)
                submit_quantity = remaining_quantity

                refreshed_price = self.executor._get_live_market_price(
                    first_exchange,
                    first_symbol,
                    execution_plan["first_is_buy"],
                )
                if refreshed_price and refreshed_price > Decimal("0"):
                    if first_price != refreshed_price:
                        logger.info(
                            f"[å¥—åˆ©æ‰§è¡Œ] [{first_tag}] ç¬¬{limit_attempt}æ¬¡é™ä»·é‡è¯•ä½¿ç”¨æœ€æ–°ç›˜å£ä»·: "
                            f"{refreshed_price} (åŸä»·={first_price})"
                        )
                        first_price = refreshed_price

                logger.info(
                    f"[å¥—åˆ©æ‰§è¡Œ] [{first_tag}] æäº¤é™ä»·è®¢å•: "
                    f"æ–¹å‘={'ä¹°å…¥' if execution_plan['first_is_buy'] else 'å–å‡º'}, "
                    f"ä»·æ ¼={first_price}, æ•°é‡={submit_quantity} (ç¬¬{limit_attempt}æ¬¡)"
                )

                limit_order = await executor._place_limit_order(
                    first_adapter,
                    first_symbol,
                    first_price,
                    submit_quantity,
                    is_buy=execution_plan["first_is_buy"],
                    absolute_offset=first_absolute_offset,
                )
                if not limit_order:
                    limit_order = await self._retry_limit_submission(
                        adapter=first_adapter,
                        symbol=first_symbol,
                        price=first_price,
                        quantity=submit_quantity,
                        is_buy=execution_plan["first_is_buy"],
                        absolute_offset=first_absolute_offset,
                        request=request,
                        exchange_name=first_exchange,
                    )

                if not limit_order:
                    if (
                        min_first_leg_qty
                        and submit_quantity + epsilon < min_first_leg_qty
                    ):
                        return await self._handle_first_leg_min_qty_failure(
                            request=request,
                            execution_plan=execution_plan,
                            first_exchange=first_exchange,
                            first_adapter=first_adapter,
                            first_symbol=first_symbol,
                            accumulated_fill=accumulated_fill,
                            submit_quantity=submit_quantity,
                            min_first_leg_qty=min_first_leg_qty,
                        )
                    return self._result_failure(
                        request,
                        f"é™ä»·è®¢å•æäº¤å¤±è´¥ ({first_exchange})",
                    )

                submitted_price = getattr(limit_order, "price", None) or first_price
                logger.info(
                    f"[å¥—åˆ©æ‰§è¡Œ] [{first_tag}] é™ä»·è®¢å•å·²æäº¤: order_id={limit_order.id}, "
                    f"ä»·æ ¼={submitted_price}, æ•°é‡={submit_quantity}"
                )

                filled_quantity = await executor.order_monitor.wait_for_order_fill(
                    limit_order,
                    first_adapter,
                    timeout=limit_timeout,
                    require_full_fill=True,
                )
                filled_decimal = await self._resolve_filled_quantity(
                    order=limit_order,
                    adapter=first_adapter,
                    symbol=first_symbol,
                    reported_filled=filled_quantity,
                )

                if filled_decimal > epsilon:
                    accumulated_fill += filled_decimal
                    has_reached_target = accumulated_fill + epsilon >= requested_quantity
                    if has_reached_target:
                        logger.info(
                            f"âœ… [å¥—åˆ©æ‰§è¡Œ] [{first_tag}] é™ä»·è…¿å·²ç´¯è®¡æˆäº¤ {accumulated_fill}ï¼Œè¾¾åˆ°æ‹†å•ç›®æ ‡ {requested_quantity}"
                        )
                        break
                    logger.info(
                        f"[å¥—åˆ©æ‰§è¡Œ] [{first_tag}] é™ä»·è®¢å•æˆäº¤: order_id={limit_order.id}, "
                        f"æˆäº¤æ•°é‡={filled_decimal} (ç´¯è®¡={accumulated_fill})"
                    )
                else:
                    if accumulated_fill <= epsilon:
                        # ğŸ”¥ 0æˆäº¤åœºæ™¯ï¼šå…ˆå°è¯•å–æ¶ˆè®¢å•ï¼Œå†åˆ¤æ–­æ˜¯å¦çœŸçš„0æˆäº¤
                        if limit_order and limit_order.id:
                            cancel_success = False
                            extra_wait_fill: Optional[Decimal] = None
                            
                            # æ£€æŸ¥ WS æ˜¯å¦å·²æ¨é€å–æ¶ˆ
                            if not executor.order_monitor.consume_ws_cancelled(limit_order.id):
                                cancel_success = await executor._cancel_order(
                                    first_adapter,
                                    limit_order.id,
                                    first_symbol,
                                )
                                
                                # å¦‚æœå–æ¶ˆå¤±è´¥ï¼Œé¢å¤–ç­‰å¾…ç¡®è®¤æ˜¯å¦å·²æˆäº¤ï¼ˆå¤„ç†ç«æ€é—®é¢˜ï¼‰
                                if not cancel_success:
                                    extra_wait_fill = await self._wait_fill_after_cancel_failure(
                                        order=limit_order,
                                        adapter=first_adapter,
                                        symbol=first_symbol,
                                        target_quantity=requested_quantity,
                                        exchange_tag=first_tag,
                                    )
                            else:
                                cancel_success = True
                            
                            # ğŸ” å¤„ç†æ’¤å•å¤±è´¥åæ£€æµ‹åˆ°çš„æˆäº¤
                            if extra_wait_fill is not None and extra_wait_fill > epsilon:
                                accumulated_fill = extra_wait_fill
                                logger.info(
                                    f"âœ… [å¥—åˆ©æ‰§è¡Œ] [{first_tag}] æ’¤å•å¤±è´¥åæ£€æµ‹åˆ°è®¢å•æˆäº¤: "
                                    f"order_id={limit_order.id}, æˆäº¤æ•°é‡={accumulated_fill}"
                                )
                                # æ£€æŸ¥æ˜¯å¦å·²åƒæ»¡ç›®æ ‡
                                if accumulated_fill + epsilon >= requested_quantity:
                                    logger.info(
                                        f"âœ… [å¥—åˆ©æ‰§è¡Œ] [{first_tag}] æ’¤å•å¤±è´¥ä½†å·²å®Œå…¨æˆäº¤ï¼Œè¾¾åˆ°æ‹†å•ç›®æ ‡ {requested_quantity}"
                                    )
                                    break  # æˆåŠŸï¼Œè·³å‡ºå¾ªç¯è¿›å…¥ç¬¬äºŒè…¿
                                # å¦‚æœéƒ¨åˆ†æˆäº¤ï¼Œç»§ç»­ä¸‹ä¸€è½®è¡¥å•
                                logger.info(
                                    f"[å¥—åˆ©æ‰§è¡Œ] [{first_tag}] æ’¤å•å¤±è´¥åéƒ¨åˆ†æˆäº¤ {accumulated_fill}ï¼Œç»§ç»­è¡¥å• (å‰©ä½™ {requested_quantity - accumulated_fill})"
                                )
                            elif not cancel_success and extra_wait_fill is None:
                                # å–æ¶ˆå¤±è´¥ä¸”æ— æˆäº¤ç¡®è®¤ï¼Œè®¢å•å¯èƒ½é—ç•™
                                logger.warning(
                                    f"âš ï¸ [å¥—åˆ©æ‰§è¡Œ] [{first_tag}] é™ä»·è®¢å•å–æ¶ˆå¤±è´¥ä¸”æ— æˆäº¤ç¡®è®¤ï¼Œ"
                                    f"è®¢å•å¯èƒ½é—ç•™åœ¨äº¤æ˜“æ‰€: order_id={limit_order.id}"
                                )
                        
                        # å¦‚æœä»ç„¶æ˜¯ 0 æˆäº¤ï¼Œè®¾ç½®ä¸­æ­¢æ ‡å¿—å¹¶ç»“æŸ
                        if accumulated_fill <= epsilon:
                            zero_fill_abort = True
                            zero_fill_order_id = limit_order.id
                            break
                    logger.warning(
                        f"[å¥—åˆ©æ‰§è¡Œ] [{first_tag}] æœ¬æ¬¡é™ä»·å•åœ¨è¶…æ—¶å‰æœªè¿½åŠ æˆäº¤: order_id={limit_order.id}, "
                        f"ç´¯è®¡æˆäº¤ä»ä¸º {accumulated_fill}"
                    )

                remaining_quantity = max(Decimal("0"), requested_quantity - accumulated_fill)
                logger.warning(
                    f"âš ï¸ [å¥—åˆ©æ‰§è¡Œ] [{first_tag}] é™ä»·è®¢å•æœªå®Œå…¨æˆäº¤ï¼Œå‰©ä½™ {remaining_quantity}ï¼Œå‡†å¤‡é‡æ–°æŒ‚å•"
                )

                if limit_order and limit_order.id:
                    if not executor.order_monitor.consume_ws_cancelled(limit_order.id):
                        await executor._cancel_order(
                            first_adapter,
                            limit_order.id,
                            first_symbol,
                        )

                # ğŸ” æ’¤å•è¿‡ç¨‹ä¸­å¯èƒ½åˆåƒæ»¡ï¼Œéœ€è¦é‡æ–°ç¡®è®¤ç´¯è®¡æˆäº¤é‡
                if (
                    limit_order
                    and accumulated_fill + epsilon < requested_quantity
                ):
                    refreshed_total = await self._resolve_filled_quantity(
                        order=limit_order,
                        adapter=first_adapter,
                        symbol=first_symbol,
                        reported_filled=None,  # å¼ºåˆ¶åˆ·æ–°
                    )
                    if refreshed_total > accumulated_fill + epsilon:
                        extra_fill = refreshed_total - accumulated_fill
                        accumulated_fill = refreshed_total
                        logger.info(
                            f"â„¹ï¸ [å¥—åˆ©æ‰§è¡Œ] [{first_tag}] é™ä»·è®¢å•åœ¨æ’¤å•æµç¨‹ä¸­æ–°å¢æˆäº¤ {extra_fill} (ç´¯è®¡={accumulated_fill})"
                        )
                        if accumulated_fill + epsilon >= requested_quantity:
                            logger.info(
                                f"âœ… [å¥—åˆ©æ‰§è¡Œ] [{first_tag}] æ’¤å•æœŸé—´å·²åƒæ»¡æ‹†å•ç›®æ ‡ {requested_quantity}ï¼Œç»“æŸè¡¥å•"
                            )
                            break

                if limit_attempt < max_partial_attempts:
                    logger.info(
                        f"[å¥—åˆ©æ‰§è¡Œ] [{first_tag}] ç´¯è®¡æˆäº¤ {accumulated_fill} æœªè¾¾åˆ°æ‹†å•ç›®æ ‡ï¼Œç»§ç»­é™ä»·è¡¥å• (å‰©ä½™ {remaining_quantity})"
                    )
                else:
                    logger.warning(
                        f"[å¥—åˆ©æ‰§è¡Œ] [{first_tag}] é™ä»·è¡¥å•æ¬¡æ•°å·²ç”¨å°½ï¼Œç´¯è®¡æˆäº¤ {accumulated_fill}ï¼Œå‰©ä½™ {remaining_quantity}"
                    )

            if zero_fill_abort:
                logger.warning(
                    f"âš ï¸ [å¥—åˆ©æ‰§è¡Œ] [{first_tag}] é™ä»·è®¢å•åœ¨è¶…æ—¶å‰æ— ä»»ä½•æˆäº¤ï¼Œç»“æŸæœ¬è½®å¥—åˆ© (order_id={zero_fill_order_id})"
                )
                return self._result_failure(
                    request,
                    f"é™ä»·è®¢å•æœªè·å¾—æœ‰æ•ˆæˆäº¤ ({first_exchange})",
                    mark_waiting=False,
                    failure_code="limit_zero_fill",
                )

            filled_decimal = accumulated_fill
            if filled_decimal + epsilon < requested_quantity:
                remaining_quantity = max(Decimal("0"), requested_quantity - filled_decimal)
                logger.warning(
                    f"[å¥—åˆ©æ‰§è¡Œ] [{first_tag}] ç´¯è®¡æˆäº¤ {filled_decimal} ä»ä½äºæ‹†å•ç›®æ ‡ {requested_quantity}ï¼Œ"
                    f"å‰©ä½™ {remaining_quantity}ï¼Œæ‰§è¡Œç´§æ€¥å¹³ä»“"
                )
                await executor._emergency_close_position(
                    exchange=first_exchange,
                    adapter=first_adapter,
                    symbol=first_symbol,
                    quantity=filled_decimal,
                    is_buy_to_close=not execution_plan["first_is_buy"],
                    request=request,
                )
                return self._result_failure(
                    request,
                    f"é™ä»·è®¢å•ç´¯è®¡æˆäº¤ä¸è¶³æ‹†å•ç›®æ ‡ ({first_exchange})",
                    partial_failure=True,
                    failed_exchange=second_exchange,
                    success_exchange=first_exchange,
                    success_quantity=filled_decimal,
                    failure_code="limit_incomplete_fill",
                )

            if (
                min_second_leg_qty
                and min_second_leg_qty > Decimal("0")
                and filled_decimal < min_second_leg_qty
            ):
                logger.warning(
                    f"[å¥—åˆ©æ‰§è¡Œ] [{first_tag}] ç´¯è®¡æˆäº¤ {filled_decimal} ä½äº {second_exchange} æœ€å°ä¸‹å•é‡ "
                    f"{min_second_leg_qty}ï¼Œå–æ¶ˆæœ¬æ¬¡æ‹†å•"
                )
                await executor._emergency_close_position(
                    exchange=first_exchange,
                    adapter=first_adapter,
                    symbol=first_symbol,
                    quantity=filled_decimal,
                    is_buy_to_close=not execution_plan["first_is_buy"],
                    request=request,
                )
                return self._result_failure(
                    request,
                    f"é™ä»·è®¢å•ç´¯è®¡æˆäº¤ä¸è¶³æœ€å°å¸‚ä»·é‡ ({first_exchange})",
                    partial_failure=True,
                    failed_exchange=second_exchange,
                    success_exchange=first_exchange,
                    success_quantity=filled_decimal,
                    failure_code="limit_min_qty_unmet",
                )

            second_order_mode = execution_plan.get("second_order_mode", "market")
            order_type_label = "æ¿€è¿›é™ä»·åƒå•" if second_order_mode == "limit" else "å¸‚ä»·è®¢å•"

            second_symbol = sell_symbol if execution_plan["first_is_buy"] else buy_symbol
            second_exchange_config = self.executor._get_exchange_mode_config(
                second_exchange,
                second_symbol,
            )
            second_uses_tick_precision = bool(
                getattr(second_exchange_config, "use_tick_precision", False)
            )
            smart_second_leg_price = bool(
                getattr(second_exchange_config, "smart_second_leg_price", False)
            )
            first_leg_clean_fill = limit_attempt == 1
            reuse_signal_price_second_leg = bool(
                getattr(second_exchange_config, "reuse_signal_price_when_second_leg", False)
            )
            if smart_second_leg_price:
                reuse_signal_price_second_leg = first_leg_clean_fill
                logger.info(
                    f"[å¥—åˆ©æ‰§è¡Œ] [{second_tag}] æ™ºèƒ½ä»·æ ¼æ¨¡å¼ -> "
                    f"{'ä¿¡å·ä»·' if reuse_signal_price_second_leg else 'æœ€æ–°ç›˜å£ä»·'} "
                    f"(ç¬¬ä¸€è…¿å°è¯•æ¬¡æ•°={limit_attempt})"
                )
            if smart_second_leg_price:
                price_mode_label = f"æ™ºèƒ½-{ 'ä¿¡å·ä»·' if reuse_signal_price_second_leg else 'æœ€æ–°ç›˜å£'}"
            elif reuse_signal_price_second_leg:
                price_mode_label = "å›ºå®š-ä¿¡å·ä»·"
            else:
                price_mode_label = "æœ€æ–°ç›˜å£"
            effective_second_offset: Optional[Decimal] = None
            signal_price_for_second_leg = executor._to_decimal_value(
                request.price_buy if execution_plan["second_is_buy"] else request.price_sell
            )

            try:
                if second_order_mode == "limit":
                    # ğŸ”¥ ä½¿ç”¨æ¿€è¿›é™ä»·å•åƒå•ï¼ˆforce_sequential_limit æ¨¡å¼ï¼‰
                    second_price: Optional[Decimal]
                    if reuse_signal_price_second_leg:
                        second_price = signal_price_for_second_leg
                        if not second_price or second_price <= Decimal("0"):
                            second_price = executor._get_live_market_price(
                                second_exchange,
                                second_symbol,
                                execution_plan["second_is_buy"],
                            ) or signal_price_for_second_leg
                    else:
                        second_price = executor._get_live_market_price(
                            second_exchange,
                            second_symbol,
                            execution_plan["second_is_buy"],
                        )
                        if not second_price or second_price <= Decimal("0"):
                            # å¦‚æœè·å–ä¸åˆ°å®æ—¶ä»·æ ¼ï¼Œä½¿ç”¨è¯·æ±‚ä¸­çš„ä»·æ ¼
                            second_price = signal_price_for_second_leg
                    second_price = executor._to_decimal_value(second_price or Decimal("0"))
                    
                    second_offset = (
                        request.limit_price_offset_buy if execution_plan["second_is_buy"]
                        else request.limit_price_offset_sell
                    )
                    effective_second_offset = (
                        None if second_uses_tick_precision else second_offset
                    )
                    
                    # ğŸ”¥ è®¡ç®—å®é™…ä¸‹å•ä»·æ ¼ï¼ˆç”¨äºæ—¥å¿—æ˜¾ç¤ºï¼‰
                    # è·å–äº¤æ˜“æ‰€é…ç½®
                    exchange_config = second_exchange_config or executor.config.exchange_order_modes.get(second_exchange)
                    limit_price_offset_pct = (
                        getattr(exchange_config, 'limit_price_offset', 0.001)
                        if exchange_config else 0.001
                    )
                    
                    # è®¡ç®—æ¿€è¿›ä»·æ ¼ï¼ˆä¸ _place_limit_order ä¸­çš„é€»è¾‘ä¸€è‡´ï¼‰
                    if effective_second_offset and effective_second_offset > Decimal('0'):
                        # å¦‚æœæœ‰ç»å¯¹åç§»ï¼Œä½¿ç”¨ç»å¯¹åç§»
                        if execution_plan["second_is_buy"]:
                            aggressive_price = second_price + effective_second_offset
                        else:
                            aggressive_price = second_price - effective_second_offset
                    else:
                        # å¦åˆ™ä½¿ç”¨ç™¾åˆ†æ¯”åç§»
                        if execution_plan["second_is_buy"]:
                            aggressive_price = second_price * (Decimal('1') + Decimal(str(limit_price_offset_pct)))
                        else:
                            aggressive_price = second_price * (Decimal('1') - Decimal(str(limit_price_offset_pct)))
                    
                    second_best_bid: Optional[Decimal] = None
                    second_best_ask: Optional[Decimal] = None
                    data_processor = getattr(executor, "data_processor", None)
                    if data_processor:
                        try:
                            second_orderbook = data_processor.get_orderbook(
                                second_exchange,
                                second_symbol,
                                max_age_seconds=executor.data_processor.data_freshness_seconds,
                            )
                            if second_orderbook:
                                if getattr(second_orderbook, "best_bid", None):
                                    second_best_bid = executor._to_decimal_value(
                                        second_orderbook.best_bid.price
                                    )
                                if getattr(second_orderbook, "best_ask", None):
                                    second_best_ask = executor._to_decimal_value(
                                        second_orderbook.best_ask.price
                                    )
                        except Exception as snapshot_err:  # pragma: no cover - snapshotä»…ç”¨äºæ—¥å¿—
                            logger.debug(
                                f"[å¥—åˆ©æ‰§è¡Œ] [{second_tag}] è®°å½•ç›˜å£å¿«ç…§å¤±è´¥: {snapshot_err}"
                            )
                    bid_display = (
                        f"{second_best_bid:.5f}"
                        if isinstance(second_best_bid, Decimal)
                        else "-"
                    )
                    ask_display = (
                        f"{second_best_ask:.5f}"
                        if isinstance(second_best_ask, Decimal)
                        else "-"
                    )

                    logger.info(
                        f"[å¥—åˆ©æ‰§è¡Œ] [{second_tag}] æäº¤{order_type_label}: "
                        f"æ–¹å‘={'ä¹°å…¥' if second_is_buy else 'å–å‡º'}, "
                        f"ç›˜å£Snapshot=Ask:{ask_display}/Bid:{bid_display}, "
                        f"å¸‚åœºä»·={second_price}, ä¸‹å•ä»·={aggressive_price}, "
                        f"ä»·æ ¼æ¨¡å¼={price_mode_label}, "
                        f"æ•°é‡={filled_decimal} (æ ¹æ®ç¬¬ä¸€è…¿å®é™…æˆäº¤æ•°é‡)"
                    )
                    
                    market_order = await executor._place_limit_order(
                        second_adapter,
                        second_symbol,
                        second_price,
                        filled_decimal,
                        is_buy=second_is_buy,
                        absolute_offset=effective_second_offset,
                        request=request,
                    )
                else:
                    logger.info(
                        f"[å¥—åˆ©æ‰§è¡Œ] [{second_tag}] æäº¤{order_type_label}: "
                        f"æ–¹å‘={'ä¹°å…¥' if second_is_buy else 'å–å‡º'}, "
                        f"æ•°é‡={filled_decimal} (æ ¹æ®ç¬¬ä¸€è…¿å®é™…æˆäº¤æ•°é‡)"
                    )
                    # åŸæœ‰çš„å¸‚ä»·å•é€»è¾‘
                    market_order = await executor._place_market_order(
                        second_adapter,
                        second_symbol,
                        filled_decimal,
                        is_buy=second_is_buy,
                        reduce_only=(not request.is_open),
                        request=request,
                    )
            except self.ReduceOnlyRestrictionError:
                await executor.reduce_only_handler.handle_reduce_only_after_partial(
                    request=request,
                    completed_exchange=first_exchange,
                    completed_adapter=first_adapter,
                    completed_symbol=first_symbol,
                    completed_quantity=filled_decimal,
                    completed_was_buy=execution_plan["first_is_buy"],
                    failing_exchange=second_exchange,
                    failing_symbol=second_symbol,
                    closing_issue=(not request.is_open),
                )
                return self._result_failure(
                    request,
                    f"{second_exchange} reduce-only é™åˆ¶ï¼Œå·²æ’¤é”€å·²æˆäº¤è…¿",
                    partial_failure=True,
                    order_buy=limit_order if execution_plan["first_is_buy"] else None,
                    order_sell=limit_order if not execution_plan["first_is_buy"] else None,
                )

            if not market_order:
                if second_order_mode == "limit":
                    # é™ä»·å•é‡è¯•
                    if reuse_signal_price_second_leg:
                        second_price_retry = signal_price_for_second_leg
                    else:
                        second_price_retry = executor._get_live_market_price(
                            second_exchange,
                            second_symbol,
                            second_is_buy,
                        ) or signal_price_for_second_leg
                    second_price_retry = executor._to_decimal_value(second_price_retry or Decimal("0"))
                    
                    retry_market = await self._retry_limit_submission(
                        adapter=second_adapter,
                        symbol=second_symbol,
                        price=second_price_retry,
                        quantity=filled_decimal,
                        is_buy=second_is_buy,
                        absolute_offset=effective_second_offset,
                        request=request,
                        exchange_name=second_exchange,
                    )
                else:
                    # å¸‚ä»·å•é‡è¯•
                    retry_market = await self._retry_market_submission(
                        adapter=second_adapter,
                        symbol=second_symbol,
                        quantity=filled_decimal,
                        is_buy=second_is_buy,
                        reduce_only=(not request.is_open),
                        request=request,
                        exchange_name=second_exchange,
                    )
                market_order = retry_market

            if not market_order:
                return await self._fail_limit_market_second_leg(
                    request=request,
                    limit_order=limit_order,
                    market_order=None,
                    execution_plan=execution_plan,
                    first_adapter=first_adapter,
                    first_exchange=first_exchange,
                    first_symbol=first_symbol,
                    filled_quantity=filled_decimal,
                    failed_exchange=second_exchange,
                    error_message=f"{order_type_label}æäº¤å¤±è´¥ ({second_exchange})",
                )

            logger.info(
                f"[å¥—åˆ©æ‰§è¡Œ] [{second_tag}] {order_type_label}å·²æäº¤: order_id={market_order.id}, æ•°é‡={filled_decimal}"
            )
            limit_completion_logged = False
            try:
                if second_order_mode == "limit":
                    # ğŸ”¥ æ¿€è¿›é™ä»·å•ä½¿ç”¨ä¸åŒçš„ç­‰å¾…é€»è¾‘
                    await executor.order_monitor.wait_for_order_fill(
                        market_order,
                        second_adapter,
                        limit_timeout,
                    )
                    market_filled_dec = executor._to_decimal_value(market_order.filled)
                    
                    # ğŸ”¥ æ£€æŸ¥æ˜¯å¦å®Œå…¨æˆäº¤
                    if market_filled_dec >= filled_decimal - epsilon:
                        # å®Œå…¨æˆäº¤ï¼ŒæˆåŠŸ
                        logger.info(
                            f"[å¥—åˆ©æ‰§è¡Œ] [{second_tag}] æ¿€è¿›é™ä»·å•å®Œå…¨æˆäº¤: order_id={market_order.id}, æˆäº¤æ•°é‡={market_filled_dec}"
                        )
                        limit_completion_logged = True
                    else:
                        # ğŸ”¥ æœªåƒæ»¡ï¼ˆåŒ…å«0æˆäº¤ï¼‰ï¼šå…ˆæ’¤å•ï¼Œå†ç”¨å¸‚ä»·è¡¥é½ï¼ŒæŒ‰å¸‚ä»·é‡è¯•ç­–ç•¥é€æ­¥æ”¾å¤§æ»‘ç‚¹
                        shortfall = max(Decimal("0"), filled_decimal - market_filled_dec)
                        if shortfall <= epsilon:
                            shortfall = Decimal("0")
                        warn_prefix = "éƒ¨åˆ†æˆäº¤" if market_filled_dec > epsilon else "æœªæˆäº¤"
                        logger.warning(
                            f"âš ï¸ [å¥—åˆ©æ‰§è¡Œ] [{second_tag}] æ¿€è¿›é™ä»·å•{warn_prefix}ï¼Œç¼ºå£ {shortfall}ï¼Œå°†æ”¹èµ°å¸‚ä»·è¡¥é½ã€‚"
                        )

                        need_market_supplement = True
                        extra_wait_fill: Optional[Decimal] = None

                        if not executor.order_monitor.consume_ws_cancelled(market_order.id):
                            cancel_success = await executor._cancel_order(
                                second_adapter,
                                market_order.id,
                                second_symbol,
                            )
                            if not cancel_success:
                                extra_wait_fill = await self._wait_fill_after_cancel_failure(
                                    order=market_order,
                                    adapter=second_adapter,
                                    symbol=second_symbol,
                                    target_quantity=filled_decimal,
                                    exchange_tag=second_tag,
                                )
                        else:
                            cancel_success = True

                        if extra_wait_fill is not None:
                            market_filled_dec = max(market_filled_dec, extra_wait_fill)
                            shortfall = max(Decimal("0"), filled_decimal - market_filled_dec)
                            if market_order:
                                market_order.filled = market_filled_dec
                            if shortfall <= epsilon:
                                need_market_supplement = False
                                limit_completion_logged = True
                                logger.info(
                                    f"âœ… [å¥—åˆ©æ‰§è¡Œ] [{second_tag}] æ’¤å•å¤±è´¥åçš„é¢å¤–ç­‰å¾…æ£€æµ‹åˆ°æˆäº¤ï¼Œ"
                                    f"order_id={market_order.id}, æˆäº¤æ•°é‡={market_filled_dec}"
                                )

                        if need_market_supplement:
                            try:
                                supplement_order, supplement_filled_dec = await self._confirm_market_fill_with_retries(
                                    initial_order=None,
                                    adapter=second_adapter,
                                    symbol=second_symbol,
                                    quantity=shortfall,
                                    is_buy=execution_plan["second_is_buy"],
                                    reduce_only=(not request.is_open),
                                    request=request,
                                    exchange_name=second_exchange,
                                    enable_internal_aggressive_retry=True,
                                )
                                if supplement_filled_dec + epsilon < shortfall:
                                    logger.error(
                                        f"âŒ [å¥—åˆ©æ‰§è¡Œ] [{second_tag}] å¸‚ä»·è¡¥é½å¤šæ¬¡å¤±è´¥ï¼Œ"
                                        f"ä»…æˆäº¤ {supplement_filled_dec} / ç›®æ ‡ {shortfall}"
                                    )
                                    return await self._fail_limit_market_second_leg(
                                        request=request,
                                        limit_order=limit_order,
                                        market_order=market_order,
                                        execution_plan=execution_plan,
                                        first_adapter=first_adapter,
                                        first_exchange=first_exchange,
                                        first_symbol=first_symbol,
                                        filled_quantity=market_filled_dec,
                                        failed_exchange=second_exchange,
                                        error_message=f"æ¿€è¿›é™ä»·ç¼ºå£å¸‚ä»·è¡¥å•å¤±è´¥ ({second_exchange})",
                                    )

                                market_filled_dec += supplement_filled_dec
                                if supplement_order:
                                    market_order = supplement_order
                                if market_order:
                                    market_order.filled = market_filled_dec
                                logger.info(
                                    f"âœ… [å¥—åˆ©æ‰§è¡Œ] [{second_tag}] å¸‚ä»·è¡¥å•æˆåŠŸ: è¡¥å•é‡={supplement_filled_dec}, "
                                    f"æ€»æˆäº¤={market_filled_dec}"
                                )
                                limit_completion_logged = True

                            except self.ReduceOnlyRestrictionError:
                                logger.error(f"âŒ [å¥—åˆ©æ‰§è¡Œ] [{second_tag}] å¸‚ä»·è¡¥å•é‡åˆ° reduce-only é™åˆ¶")
                                raise
                            except Exception as market_err:
                                logger.error(
                                    f"âŒ [å¥—åˆ©æ‰§è¡Œ] [{second_tag}] å¸‚ä»·è¡¥å•å¼‚å¸¸: {market_err}",
                                    exc_info=True,
                                )
                                return await self._fail_limit_market_second_leg(
                                    request=request,
                                    limit_order=limit_order,
                                    market_order=market_order,
                                    execution_plan=execution_plan,
                                    first_adapter=first_adapter,
                                    first_exchange=first_exchange,
                                    first_symbol=first_symbol,
                                    filled_quantity=market_filled_dec,
                                    failed_exchange=second_exchange,
                                    error_message=f"æ¿€è¿›é™ä»·ç¼ºå£å¸‚ä»·è¡¥å•å¼‚å¸¸ ({second_exchange})",
                                )
                else:
                    # åŸæœ‰çš„å¸‚ä»·å•ç¡®è®¤é€»è¾‘
                    market_order, market_filled_dec = await self._confirm_market_fill_with_retries(
                        initial_order=market_order,
                        adapter=second_adapter,
                        symbol=second_symbol,
                        quantity=filled_decimal,
                        is_buy=execution_plan["second_is_buy"],
                        reduce_only=(not request.is_open),
                        request=request,
                        exchange_name=second_exchange,
                    )
            except self.ReduceOnlyRestrictionError:
                await executor.reduce_only_handler.handle_reduce_only_after_partial(
                    request=request,
                    completed_exchange=first_exchange,
                    completed_adapter=first_adapter,
                    completed_symbol=first_symbol,
                    completed_quantity=filled_decimal,
                    completed_was_buy=execution_plan["first_is_buy"],
                    failing_exchange=second_exchange,
                    failing_symbol=second_symbol,
                    closing_issue=(not request.is_open),
                )
                return self._result_failure(
                    request,
                    f"{second_exchange} reduce-only é™åˆ¶ï¼Œå·²æ’¤é”€å·²æˆäº¤è…¿",
                    partial_failure=True,
                    order_buy=limit_order if execution_plan["first_is_buy"] else market_order,
                    order_sell=limit_order if not execution_plan["first_is_buy"] else market_order,
                )

            if market_filled_dec <= epsilon:
                order_type_display = "æ¿€è¿›é™ä»·å•" if second_order_mode == "limit" else "å¸‚ä»·è®¢å•"
                logger.warning(
                    f"[å¥—åˆ©æ‰§è¡Œ] [{second_tag}] {order_type_display}æœªåœ¨ç­‰å¾…çª—å£å†…ç¡®è®¤æˆäº¤: "
                    f"order_id={market_order.id if market_order else 'unknown'}"
                )
                return await self._fail_limit_market_second_leg(
                    request=request,
                    limit_order=limit_order,
                    market_order=market_order,
                    execution_plan=execution_plan,
                    first_adapter=first_adapter,
                    first_exchange=first_exchange,
                    first_symbol=first_symbol,
                    filled_quantity=filled_decimal,
                    failed_exchange=second_exchange,
                    error_message=f"{order_type_display}è¶…æ—¶æœªæˆäº¤ ({second_exchange})",
            )

            result_order_buy = limit_order if execution_plan["first_is_buy"] else market_order
            result_order_sell = limit_order if not execution_plan["first_is_buy"] else market_order

            order_type_display = "æ¿€è¿›é™ä»·å•" if second_order_mode == "limit" else "å¸‚ä»·è®¢å•"
            if not (second_order_mode == "limit" and limit_completion_logged):
                logger.info(
                    f"[å¥—åˆ©æ‰§è¡Œ] [{second_tag}] {order_type_display}æˆäº¤ç¡®è®¤: "
                    f"order_id={market_order.id if market_order else 'unknown'}, "
                    f"æˆäº¤æ•°é‡={market_filled_dec}"
                )
            executor._log_execution_summary(
                request=request,
                order_buy=result_order_buy,
                order_sell=result_order_sell,
                is_open=request.is_open,
                is_last_split=request.is_last_split,
            )

            return Result(
                success=True,
                order_buy=result_order_buy,
                order_sell=result_order_sell,
                success_quantity=filled_decimal,
            )

        except Exception as exc:  # pylint: disable=broad-except
            logger.error(f"[å¥—åˆ©æ‰§è¡Œ] é™ä»·+å¸‚åœºæ¨¡å¼æ‰§è¡Œå¤±è´¥: {exc}", exc_info=True)
            return self._result_failure(
                request,
                str(exc),
            )

    async def execute_limit_limit_mode(
        self,
        request: "ExecutionRequest",
    ) -> "ExecutionResult":
        executor = self.executor
        Result = self.ExecutionResult

        buy_adapter = executor.exchange_adapters.get(request.exchange_buy)
        sell_adapter = executor.exchange_adapters.get(request.exchange_sell)
        if not buy_adapter or not sell_adapter:
            return self._result_failure(
                request,
                f"äº¤æ˜“æ‰€é€‚é…å™¨ä¸å­˜åœ¨: {request.exchange_buy} æˆ– {request.exchange_sell}",
                mark_waiting=False,
            )

        buy_symbol = request.buy_symbol or request.symbol
        sell_symbol = request.sell_symbol or request.symbol
        quantity = request.quantity or Decimal('0')
        epsilon = Decimal("0.00000001")
        limit_timeout = getattr(
            executor.config.order_execution,
            "limit_order_timeout",
            60,
        ) or 60

        try:
            logger.info(
                f"[å¥—åˆ©æ‰§è¡Œ] åŒé™ä»·æ¨¡å¼ï¼šåŒæ—¶æäº¤é™ä»·è®¢å•ï¼Œ"
                f"ä¹°å…¥={request.exchange_buy}@{request.price_buy}, "
                f"å–å‡º={request.exchange_sell}@{request.price_sell}, æ•°é‡={quantity}"
            )
            buy_offset = request.limit_price_offset_buy
            sell_offset = request.limit_price_offset_sell

            buy_order_task = asyncio.create_task(
                executor._place_limit_order(
                    buy_adapter,
                    buy_symbol,
                    request.price_buy,
                    quantity,
                    is_buy=True,
                    absolute_offset=buy_offset,
                )
            )
            sell_order_task = asyncio.create_task(
                executor._place_limit_order(
                    sell_adapter,
                    sell_symbol,
                    request.price_sell,
                    quantity,
                    is_buy=False,
                    absolute_offset=sell_offset,
                )
            )

            buy_order_raw, sell_order_raw = await asyncio.gather(
                buy_order_task,
                sell_order_task,
                return_exceptions=True,
            )

            buy_error = buy_order_raw if isinstance(buy_order_raw, self.ReduceOnlyRestrictionError) else None
            sell_error = sell_order_raw if isinstance(sell_order_raw, self.ReduceOnlyRestrictionError) else None

            buy_order = buy_order_raw if not isinstance(buy_order_raw, Exception) else None
            sell_order = sell_order_raw if not isinstance(sell_order_raw, Exception) else None

            if buy_error:
                return await self._handle_reduce_only_submission_failure(
                    request=request,
                    failing_exchange=request.exchange_buy,
                    failing_symbol=buy_symbol,
                    failing_is_buy=True,
                    other_order=sell_order,
                    other_adapter=sell_adapter,
                    other_exchange=request.exchange_sell,
                    other_symbol=sell_symbol,
                    other_is_buy=False,
                    epsilon=epsilon,
                    limit_timeout=limit_timeout,
                )

            if sell_error:
                return await self._handle_reduce_only_submission_failure(
                    request=request,
                    failing_exchange=request.exchange_sell,
                    failing_symbol=sell_symbol,
                    failing_is_buy=False,
                    other_order=buy_order,
                    other_adapter=buy_adapter,
                    other_exchange=request.exchange_buy,
                    other_symbol=buy_symbol,
                    other_is_buy=True,
                    epsilon=epsilon,
                    limit_timeout=limit_timeout,
                )

            if isinstance(buy_order_raw, Exception):
                raise buy_order_raw
            if isinstance(sell_order_raw, Exception):
                raise sell_order_raw

            if not buy_order:
                buy_order = await self._retry_limit_submission(
                    adapter=buy_adapter,
                    symbol=buy_symbol,
                    price=request.price_buy,
                    quantity=quantity,
                    is_buy=True,
                    absolute_offset=buy_offset,
                    request=request,
                    exchange_name=request.exchange_buy,
                )

            if not sell_order:
                sell_order = await self._retry_limit_submission(
                    adapter=sell_adapter,
                    symbol=sell_symbol,
                    price=request.price_sell,
                    quantity=quantity,
                    is_buy=False,
                    absolute_offset=sell_offset,
                    request=request,
                    exchange_name=request.exchange_sell,
                )

            if not buy_order and not sell_order:
                return self._result_failure(
                    request,
                    "åŒé™ä»·è®¢å•å‡æäº¤å¤±è´¥",
                )

            if not buy_order:
                if sell_order:
                    await executor._cancel_order(sell_adapter, sell_order.id, sell_symbol)
                return self._result_failure(
                    request,
                    f"ä¹°å…¥é™ä»·è®¢å•æäº¤å¤±è´¥ ({request.exchange_buy})",
                )

            if not sell_order:
                await executor._cancel_order(buy_adapter, buy_order.id, buy_symbol)
                return self._result_failure(
                    request,
                    f"å–å‡ºé™ä»·è®¢å•æäº¤å¤±è´¥ ({request.exchange_sell})",
                )

            buy_fill_task = asyncio.create_task(
                executor.order_monitor.wait_for_order_fill(buy_order, buy_adapter, timeout=limit_timeout)
            )
            sell_fill_task = asyncio.create_task(
                executor.order_monitor.wait_for_order_fill(sell_order, sell_adapter, timeout=limit_timeout)
            )
            buy_filled, sell_filled = await asyncio.gather(buy_fill_task, sell_fill_task)

            buy_filled_dec = await self._resolve_filled_quantity(
                order=buy_order,
                adapter=buy_adapter,
                symbol=buy_symbol,
                reported_filled=buy_filled,
            )
            sell_filled_dec = await self._resolve_filled_quantity(
                order=sell_order,
                adapter=sell_adapter,
                symbol=sell_symbol,
                reported_filled=sell_filled,
            )

            def _is_completed(filled_dec: Decimal) -> bool:
                return filled_dec + epsilon >= quantity

            buy_completed = _is_completed(buy_filled_dec)
            sell_completed = _is_completed(sell_filled_dec)

            if buy_completed and sell_completed:
                buy_order.filled = buy_filled_dec
                sell_order.filled = sell_filled_dec
                executor._log_execution_summary(
                    request=request,
                    order_buy=buy_order,
                    order_sell=sell_order,
                    is_open=request.is_open,
                    is_last_split=request.is_last_split,
                )
                actual_quantity = self._calculate_success_quantity_from_orders(
                    buy_order,
                    sell_order,
                    fallback=quantity,
                )
                return Result(
                    success=True,
                    order_buy=buy_order,
                    order_sell=sell_order,
                    success_quantity=actual_quantity,
                )

            # âœ… åªæœ‰ä¸€æ¡è…¿æˆäº¤ï¼ˆå¦ä¸€æ¡è…¿0æˆäº¤ï¼‰â†’ ç«‹å³å–æ¶ˆæœªæˆäº¤è…¿å¹¶å¯åŠ¨è¡¥ä»“æµç¨‹
            if buy_completed ^ sell_completed:
                missing_buy = not buy_completed
                shortfall = (
                    sell_filled_dec - buy_filled_dec
                    if missing_buy else
                    buy_filled_dec - sell_filled_dec
                )
                if shortfall > epsilon:
                    logger.warning(
                        f"âš ï¸ [å¥—åˆ©æ‰§è¡Œ] åŒé™ä»·æ¨¡å¼å‡ºç°å•è…¿æˆäº¤ï¼Œ"
                        f"{'ä¹°è…¿' if missing_buy else 'å–è…¿'} ç¼ºå£ {shortfall}ï¼Œ"
                        "å…ˆæ¿€è¿›é™ä»·è¡¥ä»“ï¼Œå‰©ä½™å†å¸‚ä»·å…œåº•"
                    )
                    return await self._handle_single_leg_shortfall(
                        request=request,
                        buy_order=buy_order,
                        sell_order=sell_order,
                        buy_adapter=buy_adapter,
                        sell_adapter=sell_adapter,
                        buy_symbol=buy_symbol,
                        sell_symbol=sell_symbol,
                        missing_buy=missing_buy,
                        shortfall=shortfall,
                        target_quantity=quantity,
                        epsilon=epsilon,
                        cancel_opposite_order=False,
                        result_quantity=Decimal(str(quantity)),
                    )

            if not buy_completed and not sell_completed:
                has_buy_fill = buy_filled_dec > epsilon
                has_sell_fill = sell_filled_dec > epsilon

                if not has_buy_fill and not has_sell_fill:
                    await executor._cancel_order(buy_adapter, buy_order.id, buy_symbol)
                    await executor._cancel_order(sell_adapter, sell_order.id, sell_symbol)
                    logger.info(
                        "â†©ï¸ [å¥—åˆ©æ‰§è¡Œ] åŒé™ä»·è…¿å‡ 0 æˆäº¤ï¼Œå·²å–æ¶ˆ buy=%s / sell=%s",
                        buy_order.id,
                        sell_order.id,
                    )
                    refreshed_buy = await self._resolve_filled_quantity(
                        order=buy_order,
                        adapter=buy_adapter,
                        symbol=buy_symbol,
                        reported_filled=None,
                    )
                    refreshed_sell = await self._resolve_filled_quantity(
                        order=sell_order,
                        adapter=sell_adapter,
                        symbol=sell_symbol,
                        reported_filled=None,
                    )
                    if refreshed_buy > epsilon or refreshed_sell > epsilon:
                        buy_filled_dec = refreshed_buy
                        sell_filled_dec = refreshed_sell
                        has_buy_fill = buy_filled_dec > epsilon
                        has_sell_fill = sell_filled_dec > epsilon
                        logger.info(
                            "â„¹ï¸ [å¥—åˆ©æ‰§è¡Œ] å–æ¶ˆåŒé™ä»·åæ£€æµ‹åˆ°å»¶è¿Ÿæˆäº¤: buy=%s, sell=%s",
                            buy_filled_dec,
                            sell_filled_dec,
                        )
                    if not has_buy_fill and not has_sell_fill:
                        return self._result_failure(
                            request,
                            "åŒé™ä»·è®¢å•å‡æœªæˆäº¤",
                            order_buy=buy_order,
                            order_sell=sell_order,
                            failure_code="dual_limit_no_fill",
                            mark_waiting=False,
                        )

                if has_buy_fill ^ has_sell_fill:
                    missing_buy = not has_buy_fill
                    fallback_quantity = (
                        sell_filled_dec - buy_filled_dec
                        if missing_buy else
                        buy_filled_dec - sell_filled_dec
                    )
                    if fallback_quantity > epsilon:
                        return await self._handle_single_leg_shortfall(
                            request=request,
                            buy_order=buy_order,
                            sell_order=sell_order,
                            buy_adapter=buy_adapter,
                            sell_adapter=sell_adapter,
                            buy_symbol=buy_symbol,
                            sell_symbol=sell_symbol,
                            missing_buy=missing_buy,
                            shortfall=fallback_quantity,
                            target_quantity=quantity,
                            epsilon=epsilon,
                            cancel_opposite_order=True,
                            result_quantity=fallback_quantity,
                        )
                    return self._result_failure(
                        request,
                        "å•è¾¹æˆäº¤ç¼ºå£æ— æ³•è¯†åˆ«",
                        order_buy=buy_order,
                        order_sell=sell_order,
                    )

                buy_remaining = (quantity - buy_filled_dec).copy_abs()
                sell_remaining = (quantity - sell_filled_dec).copy_abs()
                fill_failed = False

                async def _complete_leg(remaining: Decimal, *, is_buy: bool) -> Decimal:
                    exchange_name = request.exchange_buy if is_buy else request.exchange_sell
                    adapter = buy_adapter if is_buy else sell_adapter
                    symbol = buy_symbol if is_buy else sell_symbol
                    leg_label = "ä¹°è…¿" if is_buy else "å–è…¿"
                    if remaining <= epsilon:
                        return Decimal("0")
                    logger.warning(
                        f"âš ï¸ [å¥—åˆ©æ‰§è¡Œ] åŒè…¿éƒ¨åˆ†æˆäº¤ï¼Œ{leg_label} å‰©ä½™ {remaining} æœªåˆ°è¾¾æ‹†å•ç›®æ ‡ï¼Œå¯åŠ¨è¡¥å•æµç¨‹ï¼ˆæ¿€è¿›é™ä»·ä¼˜å…ˆï¼‰"
                    )
                    added = await self._fill_leg_to_target(
                        adapter=adapter,
                        symbol=symbol,
                        exchange_name=exchange_name,
                        is_buy=is_buy,
                        remaining_quantity=remaining,
                        request=request,
                        epsilon=epsilon,
                    )
                    return added

                try:
                    if buy_remaining > epsilon:
                        buy_filled_dec += await _complete_leg(buy_remaining, is_buy=True)
                    if sell_remaining > epsilon:
                        sell_filled_dec += await _complete_leg(sell_remaining, is_buy=False)
                except self.ReduceOnlyRestrictionError:
                    executor.reduce_only_handler.register_reduce_only_event(
                        request,
                        request.exchange_buy if buy_remaining > sell_remaining else request.exchange_sell,
                        buy_symbol if buy_remaining > sell_remaining else sell_symbol,
                        closing_issue=(not request.is_open),
                        reason="fill_to_target_reduce_only",
                    )
                    fill_failed = True
                except Exception as fill_exc:
                    logger.warning(
                        f"âš ï¸ [å¥—åˆ©æ‰§è¡Œ] åŒè…¿éƒ¨åˆ†æˆäº¤è¡¥é½è‡³æ‹†å•é‡å¤±è´¥ï¼Œå°†é™çº§ä¸ºå·®å€¼è¡¥é½: {fill_exc}",
                        exc_info=True,
                    )
                    fill_failed = True

                still_missing_buy = (quantity - buy_filled_dec) > epsilon
                still_missing_sell = (quantity - sell_filled_dec) > epsilon
                if not fill_failed and not (still_missing_buy or still_missing_sell):
                    executor._log_execution_summary(
                        request=request,
                        order_buy=buy_order,
                        order_sell=sell_order,
                        is_open=request.is_open,
                        is_last_split=request.is_last_split,
                    )
                    return Result(
                        success=True,
                        order_buy=buy_order,
                        order_sell=sell_order,
                        success_quantity=min(buy_filled_dec, sell_filled_dec, quantity),
                    )

                # è‹¥æ— æ³•è¡¥é½æ‹†å•ç›®æ ‡ï¼Œåˆ™ç»ˆæ­¢æœ¬æ¬¡æ‰§è¡Œé¿å…è¿›ä¸€æ­¥æ··ä¹±
                await executor._cancel_order(buy_adapter, buy_order.id, buy_symbol)
                await executor._cancel_order(sell_adapter, sell_order.id, sell_symbol)

                reason = "åŒè…¿éƒ¨åˆ†æˆäº¤è¡¥é½è‡³æ‹†å•é‡å¤±è´¥"
                if fill_failed:
                    reason += "ï¼ˆè¡¥å•é˜¶æ®µå¼‚å¸¸æˆ–å—é™ï¼‰"
                elif still_missing_buy or still_missing_sell:
                    reason += "ï¼ˆå¸‚ä»·è¡¥å•æˆäº¤é‡ä¸è¶³ï¼‰"

                return self._result_failure(
                    request,
                    reason,
                    order_buy=buy_order,
                    order_sell=sell_order,
                    failure_code="dual_partial_fill_incomplete",
                )

            missing_buy = not buy_completed
            shortfall = (
                sell_filled_dec - buy_filled_dec
                if missing_buy else
                buy_filled_dec - sell_filled_dec
            )
            fallback_quantity = shortfall if shortfall > epsilon else Decimal('0')

            if fallback_quantity <= epsilon:
                await executor._cancel_order(buy_adapter, buy_order.id, buy_symbol)
                await executor._cancel_order(sell_adapter, sell_order.id, sell_symbol)
                return self._result_failure(
                    request,
                    "é™ä»·è®¢å•æœªäº§ç”Ÿéœ€è¦è¡¥é½çš„æˆäº¤å·®é¢",
                    order_buy=buy_order,
                    order_sell=sell_order,
                )

            return await self._handle_single_leg_shortfall(
                request=request,
                buy_order=buy_order,
                sell_order=sell_order,
                buy_adapter=buy_adapter,
                sell_adapter=sell_adapter,
                buy_symbol=buy_symbol,
                sell_symbol=sell_symbol,
                missing_buy=missing_buy,
                shortfall=fallback_quantity,
                target_quantity=quantity,
                epsilon=epsilon,
                cancel_opposite_order=False,
                result_quantity=Decimal(str(quantity)),
            )

        except Exception as exc:  # pylint: disable=broad-except
            logger.error(f"[å¥—åˆ©æ‰§è¡Œ] åŒé™ä»·æ¨¡å¼æ‰§è¡Œå¤±è´¥: {exc}", exc_info=True)
            return self._result_failure(
                request,
                str(exc),
            )
    
    async def _fail_limit_market_second_leg(
        self,
        *,
        request: "ExecutionRequest",
        limit_order: OrderData,
        market_order: Optional[OrderData],
        execution_plan: Dict[str, Any],
        first_adapter: ExchangeInterface,
        first_exchange: str,
        first_symbol: str,
        filled_quantity: Optional[Decimal],
        failed_exchange: str,
        error_message: str,
    ) -> "ExecutionResult":
        executor = self.executor
        epsilon = Decimal("0.00000001")

        first_leg_qty = executor._to_decimal_value(filled_quantity or Decimal("0"))
        second_leg_qty = Decimal("0")
        if market_order is not None:
            try:
                second_leg_qty = executor._to_decimal_value(
                    getattr(market_order, "filled", Decimal("0"))
                )
            except (InvalidOperation, TypeError, ValueError):
                second_leg_qty = Decimal("0")

        close_first_success = True
        if first_leg_qty > epsilon:
            try:
                close_first_success = await executor._emergency_close_position(
                    exchange=first_exchange,
                    adapter=first_adapter,
                    symbol=first_symbol,
                    quantity=first_leg_qty,
                    is_buy_to_close=not execution_plan["first_is_buy"],
                    request=request,
                )
            except Exception as exc:  # pylint: disable=broad-except
                logger.error(
                    f"âŒ [å¥—åˆ©æ‰§è¡Œ] [{executor._format_exchange_tag(first_exchange)}] "
                    f"ç´§æ€¥å¹³ä»“å¼‚å¸¸: {exc}",
                    exc_info=True,
                )
                close_first_success = False

        close_second_success = True
        if second_leg_qty > epsilon:
            second_exchange = execution_plan.get("second_exchange")
            second_symbol = (
                (request.buy_symbol or request.symbol)
                if execution_plan.get("second_is_buy")
                else (request.sell_symbol or request.symbol)
            )
            second_adapter = (
                executor.exchange_adapters.get(second_exchange)
                if second_exchange else None
            )

            if second_adapter:
                try:
                    close_second_success = await executor._emergency_close_position(
                        exchange=second_exchange,
                        adapter=second_adapter,
                        symbol=second_symbol,
                        quantity=second_leg_qty,
                        is_buy_to_close=not execution_plan.get("second_is_buy", False),
                        request=request,
                    )
                except Exception as exc:  # pylint: disable=broad-except
                    logger.error(
                        f"âŒ [å¥—åˆ©æ‰§è¡Œ] [{executor._format_exchange_tag(second_exchange)}] "
                        f"ç¬¬äºŒè…¿ç´§æ€¥å¹³ä»“å¼‚å¸¸: {exc}",
                        exc_info=True,
                    )
                    close_second_success = False
            else:
                close_second_success = False
                logger.error(
                    f"âŒ [å¥—åˆ©æ‰§è¡Œ] ç¬¬äºŒè…¿é€‚é…å™¨ä¸å­˜åœ¨ï¼Œæ— æ³•å›æ»š {second_exchange}"
                )

        if not close_first_success or not close_second_success:
            reason_hint = []
            if not close_first_success:
                reason_hint.append(f"{first_exchange}ç´§æ€¥å¹³ä»“å¤±è´¥")
            if not close_second_success and second_leg_qty > epsilon:
                reason_hint.append(f"{execution_plan.get('second_exchange')}ç¬¬äºŒè…¿å›æ»šå¤±è´¥")
            if reason_hint:
                self._mark_manual_intervention(
                    request,
                    "ï¼›".join(reason_hint) or "ç´§æ€¥å¹³ä»“å¤±è´¥",
                )

        result_order_buy = limit_order if execution_plan["first_is_buy"] else market_order
        result_order_sell = limit_order if not execution_plan["first_is_buy"] else market_order

        return self._result_failure(
            request,
            error_message,
            order_buy=result_order_buy,
            order_sell=result_order_sell,
            partial_failure=True,
            failed_exchange=failed_exchange,
            success_exchange=first_exchange,
            success_quantity=first_leg_qty,
        )

    async def _handle_market_market_submission_failure(
        self,
        *,
        request: "ExecutionRequest",
        buy_order: Optional[OrderData],
        sell_order: Optional[OrderData],
        buy_adapter: ExchangeInterface,
        sell_adapter: ExchangeInterface,
        buy_symbol: str,
        sell_symbol: str,
    ) -> "ExecutionResult":
        executor = self.executor
        if not buy_order and not sell_order:
            return self._result_failure(
                request,
                "ä¸¤ä¸ªäº¤æ˜“æ‰€è®¢å•éƒ½æäº¤å¤±è´¥",
            )

        buy_failed = buy_order is None
        success_order = sell_order if buy_failed else buy_order
        success_adapter = sell_adapter if buy_failed else buy_adapter
        success_symbol = sell_symbol if buy_failed else buy_symbol
        success_exchange = request.exchange_sell if buy_failed else request.exchange_buy
        failed_exchange = request.exchange_buy if buy_failed else request.exchange_sell

        filled_decimal = Decimal("0")
        if success_order:
            _, filled_decimal = await self._confirm_market_fill_with_retries(
                initial_order=success_order,
                adapter=success_adapter,
                symbol=success_symbol,
                quantity=request.quantity,
                is_buy=(not buy_failed),
                reduce_only=(not request.is_open),
                request=request,
                exchange_name=success_exchange,
                allow_resubmit=False,
                max_attempts=1,
            )
            if filled_decimal > Decimal("0"):
                await executor._emergency_close_position(
                    exchange=success_exchange,
                    adapter=success_adapter,
                    symbol=success_symbol,
                    quantity=filled_decimal,
                    is_buy_to_close=buy_failed,
                    request=request,
                )

        return self._result_failure(
            request,
            f"{failed_exchange} å¸‚ä»·è®¢å•æäº¤å¤±è´¥",
            order_buy=buy_order,
            order_sell=sell_order,
            partial_failure=bool(success_order),
            failed_exchange=failed_exchange,
            success_exchange=success_exchange if success_order else None,
            success_quantity=filled_decimal,
        )

    async def execute_market_market_mode(
        self,
        request: "ExecutionRequest",
    ) -> "ExecutionResult":
        executor = self.executor
        Result = self.ExecutionResult

        buy_adapter = executor.exchange_adapters.get(request.exchange_buy)
        sell_adapter = executor.exchange_adapters.get(request.exchange_sell)

        if not buy_adapter or not sell_adapter:
            return self._result_failure(
                request,
                f"äº¤æ˜“æ‰€é€‚é…å™¨ä¸å­˜åœ¨: {request.exchange_buy} æˆ– {request.exchange_sell}",
                mark_waiting=False,
            )

        buy_symbol = request.buy_symbol or request.symbol
        sell_symbol = request.sell_symbol or request.symbol

        if self._should_use_lighter_ws_batch(request, buy_adapter, sell_adapter):
            return await self._execute_lighter_ws_batch(
                request=request,
                adapter=buy_adapter,
                buy_symbol=buy_symbol,
                sell_symbol=sell_symbol,
            )

        try:
            buy_order_task = asyncio.create_task(
                executor._place_market_order(
                    buy_adapter,
                    buy_symbol,
                    request.quantity,
                    is_buy=True,
                    reduce_only=(not request.is_open),
                    request=request,
                )
            )

            sell_order_task = asyncio.create_task(
                executor._place_market_order(
                    sell_adapter,
                    sell_symbol,
                    request.quantity,
                    is_buy=False,
                    reduce_only=(not request.is_open),
                    request=request,
                )
            )

            buy_order, sell_order = await asyncio.gather(buy_order_task, sell_order_task)

            if not buy_order:
                buy_order = await self._retry_market_submission(
                    adapter=buy_adapter,
                    symbol=buy_symbol,
                    quantity=request.quantity,
                    is_buy=True,
                    reduce_only=(not request.is_open),
                    request=request,
                    exchange_name=request.exchange_buy,
                )
            if not sell_order:
                sell_order = await self._retry_market_submission(
                    adapter=sell_adapter,
                    symbol=sell_symbol,
                    quantity=request.quantity,
                    is_buy=False,
                    reduce_only=(not request.is_open),
                    request=request,
                    exchange_name=request.exchange_sell,
                )

            if not buy_order and not sell_order:
                logger.error(
                    f"âŒ [é£é™©æ§åˆ¶] ä¸¤ä¸ªäº¤æ˜“æ‰€è®¢å•éƒ½å¤±è´¥: {request.exchange_buy}, {request.exchange_sell}"
                )
                return self._result_failure(
                    request,
                    "ä¸¤ä¸ªäº¤æ˜“æ‰€è®¢å•éƒ½æäº¤å¤±è´¥",
                )

            if not buy_order or not sell_order:
                return await self._handle_market_market_submission_failure(
                    request=request,
                    buy_order=buy_order,
                    sell_order=sell_order,
                    buy_adapter=buy_adapter,
                    sell_adapter=sell_adapter,
                    buy_symbol=buy_symbol,
                    sell_symbol=sell_symbol,
                )

            logger.info(
                f"[å¥—åˆ©æ‰§è¡Œ] ä¸¤ä¸ªå¸‚ä»·è®¢å•å·²æäº¤: "
                f"ä¹°å…¥è®¢å•={buy_order.id} å–å‡ºè®¢å•={sell_order.id}"
            )

            try:
                buy_order, buy_filled_dec = await self._confirm_market_fill_with_retries(
                    initial_order=buy_order,
                    adapter=buy_adapter,
                    symbol=buy_symbol,
                    quantity=request.quantity,
                    is_buy=True,
                    reduce_only=(not request.is_open),
                    request=request,
                    exchange_name=request.exchange_buy,
                )
            except self.ReduceOnlyRestrictionError:
                executor.reduce_only_handler.register_reduce_only_event(
                    request,
                    request.exchange_buy,
                    buy_symbol,
                    closing_issue=(not request.is_open),
                    reason="ä¹°å•è§¦å‘ reduce-only",
                )
                return self._result_failure(
                    request,
                    f"{request.exchange_buy} å¸‚ä»·è®¢å•å›  reduce-only å—é™",
                    order_buy=buy_order,
                    order_sell=sell_order,
                )

            try:
                sell_order, sell_filled_dec = await self._confirm_market_fill_with_retries(
                    initial_order=sell_order,
                    adapter=sell_adapter,
                    symbol=sell_symbol,
                    quantity=request.quantity,
                    is_buy=False,
                    reduce_only=(not request.is_open),
                    request=request,
                    exchange_name=request.exchange_sell,
                )
            except self.ReduceOnlyRestrictionError:
                executor.reduce_only_handler.register_reduce_only_event(
                    request,
                    request.exchange_sell,
                    sell_symbol,
                    closing_issue=(not request.is_open),
                    reason="å–å•è§¦å‘ reduce-only",
                )
                return self._result_failure(
                    request,
                    f"{request.exchange_sell} å¸‚ä»·è®¢å•å›  reduce-only å—é™",
                    order_buy=buy_order,
                    order_sell=sell_order,
                )

            epsilon = Decimal("0.00000001")

            if buy_filled_dec <= epsilon and sell_filled_dec <= epsilon:
                logger.error("âŒ [é£é™©æ§åˆ¶] ä¸¤ä¸ªè®¢å•éƒ½æœªæˆäº¤")
                return self._result_failure(
                    request,
                    "ä¸¤ä¸ªè®¢å•éƒ½æœªæˆäº¤",
                    order_buy=buy_order,
                    order_sell=sell_order,
                )

            if buy_filled_dec <= epsilon or sell_filled_dec <= epsilon:
                buy_order.filled = buy_filled_dec
                sell_order.filled = sell_filled_dec
                filled_exchange = request.exchange_sell if buy_filled_dec <= epsilon else request.exchange_buy
                unfilled_exchange = request.exchange_buy if buy_filled_dec <= epsilon else request.exchange_sell
                filled_quantity = sell_filled_dec if buy_filled_dec <= epsilon else buy_filled_dec
                filled_adapter = sell_adapter if buy_filled_dec <= epsilon else buy_adapter
                filled_symbol = sell_symbol if buy_filled_dec <= epsilon else buy_symbol
                is_buy_unfilled = (buy_filled_dec <= epsilon)

                logger.error(
                    f"âŒ [é£é™©æ§åˆ¶] éƒ¨åˆ†æˆäº¤: {filled_exchange} æˆäº¤ {filled_quantity}, "
                    f"{unfilled_exchange} æœªæˆäº¤ã€‚å°†å¹³æ‰ {filled_exchange} è®¢å•"
                )

                await executor._emergency_close_position(
                    exchange=filled_exchange,
                    adapter=filled_adapter,
                    symbol=filled_symbol,
                    quantity=Decimal(str(filled_quantity)),
                    is_buy_to_close=is_buy_unfilled,
                    request=request,
                )

                return self._result_failure(
                    request,
                    f"{unfilled_exchange} è®¢å•æœªæˆäº¤ï¼Œå·²å¹³æ‰ {filled_exchange} è®¢å•ï¼Œç­‰å¾…äººå·¥ä»‹å…¥",
                    order_buy=buy_order,
                    order_sell=sell_order,
                    partial_failure=True,
                    failed_exchange=unfilled_exchange,
                    success_exchange=filled_exchange,
                    success_quantity=Decimal(str(filled_quantity)),
                )

            buy_order.filled = buy_filled_dec
            sell_order.filled = sell_filled_dec
            executor._log_execution_summary(
                request=request,
                order_buy=buy_order,
                order_sell=sell_order,
                is_open=request.is_open,
                is_last_split=request.is_last_split,
            )
            actual_quantity = self._calculate_success_quantity_from_orders(
                buy_order,
                sell_order,
                fallback=request.quantity,
            )

            return Result(
                success=True,
                order_buy=buy_order,
                order_sell=sell_order,
                success_quantity=actual_quantity,
            )

        except Exception as exc:  # pylint: disable=broad-except
            logger.error(f"[å¥—åˆ©æ‰§è¡Œ] å¸‚ä»·+å¸‚ä»·æ¨¡å¼æ‰§è¡Œå¤±è´¥: {exc}", exc_info=True)
            return self._result_failure(
                request,
                str(exc),
            )

    def _should_use_lighter_ws_batch(
        self,
        request: "ExecutionRequest",
        buy_adapter: Optional[ExchangeInterface],
        sell_adapter: Optional[ExchangeInterface],
    ) -> bool:
        if not buy_adapter or not sell_adapter:
            return False
        buy_exchange = (request.exchange_buy or "").lower()
        sell_exchange = (request.exchange_sell or "").lower()
        if buy_exchange != sell_exchange:
            return False
        if buy_exchange != "lighter":
            return False
        if buy_adapter is not sell_adapter:
            return False
        return hasattr(buy_adapter, "place_market_orders_ws_batch")

    async def _execute_lighter_ws_batch(
        self,
        request: "ExecutionRequest",
        adapter: ExchangeInterface,
        buy_symbol: str,
        sell_symbol: str,
    ) -> "ExecutionResult":
        executor = self.executor
        Result = self.ExecutionResult
        limit_timeout = getattr(
            executor.config.order_execution,
            "limit_order_timeout",
            60,
        ) or 60

        if not adapter or not hasattr(adapter, "place_market_orders_ws_batch"):
            return self._result_failure(
                request,
                "lighteræ‰¹é‡ä¸‹å•æœªå¯ç”¨",
            )

        reduce_only_flag = not request.is_open
        orders_payload = []
        for side, symbol in (("buy", buy_symbol), ("sell", sell_symbol)):
            payload = {
                "symbol": symbol,
                "side": side,
                "quantity": request.quantity,
            }
            # ä»…åœ¨éSPOTè…¿ä¸Šé™„åŠ  reduce_onlyï¼ˆç°è´§ä¸æ”¯æŒ reduce_onlyï¼‰
            is_spot_leg = "SPOT" in str(symbol).upper()
            if reduce_only_flag and not is_spot_leg:
                payload["reduce_only"] = True
            orders_payload.append(payload)

        try:
            slippage_percent = executor._get_slippage_percent(request)
            response = await adapter.place_market_orders_ws_batch(
                orders_payload,
                slippage_percent=slippage_percent,
            )
        except Exception as exc:  # pylint: disable=broad-except
            logger.error(f"âŒ [å¥—åˆ©æ‰§è¡Œ] lighteræ‰¹é‡å¸‚ä»·å•å¤±è´¥: {exc}", exc_info=True)
            
            # ğŸ”¥ æ£€æŸ¥æ˜¯å¦æ˜¯ reduce-only é”™è¯¯ï¼ˆ21740ï¼‰ï¼Œè§¦å‘æ¢é’ˆæœºåˆ¶
            if executor.reduce_only_handler.is_reduce_only_error(exc):
                exchange_name = executor._get_exchange_name(adapter)
                # ä¸ºä¸¤ä¸ª symbol éƒ½æ³¨å†Œ reduce-only äº‹ä»¶
                for symbol in [buy_symbol, sell_symbol]:
                    executor.reduce_only_handler.register_reduce_only_event(
                        request,
                        exchange_name,
                        symbol,
                        closing_issue=reduce_only_flag,
                        reason=str(exc)
                    )
                logger.warning(
                    f"âš ï¸ [å¥—åˆ©æ‰§è¡Œ] {exchange_name} æ‰¹é‡å¸‚ä»·å•é‡åˆ° reduce-only é™åˆ¶ï¼ˆ21740ï¼‰ï¼Œ"
                    f"å·²è§¦å‘æ¢é’ˆæœºåˆ¶ï¼Œç­‰å¾…å¸‚åœºæ¢å¤"
                )
            
            return self._result_failure(request, str(exc))

        if not response or not isinstance(response, dict):
            return self._result_failure(
                request,
                "lighteræ‰¹é‡ä¸‹å•æ— è¿”å›ç»“æœ",
            )

        skipped_orders = response.get("skipped_orders") or []
        orders_data = response.get("orders") or []
        if not orders_data:
            if skipped_orders:
                logger.info(
                    f"â„¹ï¸ [å¥—åˆ©æ‰§è¡Œ] lighteræ‰¹é‡å¸‚ä»·å•æœªå‘é€ï¼ŒåŸå› : æ— å¯å¹³ä»“æŒä»“ {skipped_orders}"
                )
                return Result(success=True, success_quantity=Decimal('0'))
            return self._result_failure(
                request,
                "lighteræ‰¹é‡ä¸‹å•æ— è¿”å›è®¢å•",
            )

        order_buy = executor._select_order_by_side(orders_data, OrderSide.BUY)
        order_sell = executor._select_order_by_side(orders_data, OrderSide.SELL)

        if order_buy:
            executor._register_pending_order(order_buy)
        if order_sell:
            executor._register_pending_order(order_sell)
        notify_network_recovered(request.exchange_buy)

        buy_order_id = order_buy.id if order_buy else "-"
        sell_order_id = order_sell.id if order_sell else "-"
        logger.info(
            f"[å¥—åˆ©æ‰§è¡Œ] lighteræ‰¹é‡å¸‚ä»·å•å·²æäº¤: ä¹°å•={buy_order_id}, å–å•={sell_order_id}"
        )

        buy_filled_task = asyncio.create_task(
            executor.order_monitor.wait_for_order_fill(
                order_buy,
                adapter,
                timeout=limit_timeout,
                is_market_order=True,
            )
        ) if order_buy else None
        sell_filled_task = asyncio.create_task(
            executor.order_monitor.wait_for_order_fill(
                order_sell,
                adapter,
                timeout=limit_timeout,
                is_market_order=True,
            )
        ) if order_sell else None

        buy_filled = await buy_filled_task if buy_filled_task else None
        sell_filled = await sell_filled_task if sell_filled_task else None
        buy_filled_dec = executor._to_decimal_value(buy_filled or Decimal("0"))
        sell_filled_dec = executor._to_decimal_value(sell_filled or Decimal("0"))
        if order_buy:
            order_buy.filled = buy_filled_dec
        if order_sell:
            order_sell.filled = sell_filled_dec

        has_buy = order_buy is not None
        has_sell = order_sell is not None

        if has_buy and has_sell:
            if buy_filled_dec <= Decimal("0") and sell_filled_dec <= Decimal("0"):
                logger.error("âŒ [é£é™©æ§åˆ¶] lighteræ‰¹é‡å¸‚ä»·å•ä¸¤ä¸ªæ–¹å‘å‡æœªæˆäº¤")
                return self._result_failure(
                    request,
                    "ä¸¤ä¸ªè®¢å•éƒ½æœªæˆäº¤",
                    order_buy=order_buy,
                    order_sell=order_sell,
                )

            if buy_filled_dec <= Decimal("0") or sell_filled_dec <= Decimal("0"):
                is_buy_unfilled = buy_filled_dec <= Decimal("0")
                filled_quantity = sell_filled_dec if is_buy_unfilled else buy_filled_dec
                filled_symbol = sell_symbol if is_buy_unfilled else buy_symbol

                logger.error(
                    f"âŒ [é£é™©æ§åˆ¶] lighteræ‰¹é‡å¸‚ä»·å•éƒ¨åˆ†æˆäº¤: "
                    f"{'å–å•' if is_buy_unfilled else 'ä¹°å•'} æˆåŠŸ {filled_quantity}, "
                    f"{'ä¹°å•' if is_buy_unfilled else 'å–å•'} æœªæˆäº¤ã€‚"
                )

                await executor._emergency_close_position(
                    exchange=request.exchange_buy,
                    adapter=adapter,
                    symbol=filled_symbol,
                    quantity=Decimal(str(filled_quantity)),
                    is_buy_to_close=is_buy_unfilled,
                    request=request,
                )

                return self._result_failure(
                    request,
                    "lighteræ‰¹é‡å¸‚ä»·å•éƒ¨åˆ†æˆäº¤ï¼Œå·²å¹³æ‰æˆåŠŸè…¿",
                    order_buy=order_buy,
                    order_sell=order_sell,
                    partial_failure=True,
                    failed_exchange=request.exchange_buy,
                    success_exchange=request.exchange_buy,
                    success_quantity=Decimal(str(filled_quantity)) if filled_quantity else Decimal('0'),
                )

            executor._log_execution_summary(
                request=request,
                order_buy=order_buy,
                order_sell=order_sell,
                is_open=request.is_open,
                is_last_split=request.is_last_split,
            )
            actual_quantity = self._calculate_success_quantity_from_orders(
                order_buy,
                order_sell,
                fallback=request.quantity,
            )

            return Result(
                success=True,
                order_buy=order_buy,
                order_sell=order_sell,
                success_quantity=actual_quantity,
            )

        pending_order = order_buy or order_sell
        if pending_order:
            await executor._cancel_order(adapter, pending_order.id, pending_order.symbol)

        return self._result_failure(
            request,
            "lighteræ‰¹é‡å¸‚ä»·å•æœªå®Œå…¨æäº¤",
            order_buy=order_buy,
            order_sell=order_sell,
        )

    async def _handle_reduce_only_submission_failure(
        self,
        *,
        request: "ExecutionRequest",
        failing_exchange: str,
        failing_symbol: str,
        failing_is_buy: bool,
        other_order: Optional[OrderData],
        other_adapter: ExchangeInterface,
        other_exchange: str,
        other_symbol: str,
        other_is_buy: bool,
        epsilon: Decimal,
        limit_timeout: float,
    ) -> "ExecutionResult":
        executor = self.executor
        logger.warning(
            "âš ï¸ [reduce-only] %s %s é™ä»·ä¸‹å•è¢«æ‹’ç»ï¼Œä»…å…è®¸å¹³ä»“ï¼Œå¼€å§‹å¤„ç†å¯¹è…¿",
            failing_exchange,
            failing_symbol,
        )

        filled_dec = Decimal("0")
        reported = None
        if other_order:
            try:
                reported = await executor.order_monitor.wait_for_order_fill(
                    other_order,
                    other_adapter,
                    timeout=limit_timeout,
                )
            except Exception:
                reported = None
            filled_dec = await self._resolve_filled_quantity(
                order=other_order,
                adapter=other_adapter,
                symbol=other_symbol,
                reported_filled=reported,
            )

        if filled_dec > epsilon and executor.reduce_only_handler:
            await executor.reduce_only_handler.handle_reduce_only_after_partial(
                request=request,
                completed_exchange=other_exchange,
                completed_adapter=other_adapter,
                completed_symbol=other_symbol,
                completed_quantity=filled_dec,
                completed_was_buy=other_is_buy,
                failing_exchange=failing_exchange,
                failing_symbol=failing_symbol,
                closing_issue=(not request.is_open),
            )
        elif other_order:
            await executor._cancel_order(other_adapter, other_order.id, other_symbol)

        message = (
            f"{failing_exchange} reduce-only é™åˆ¶ï¼Œå·²å¤„ç†{('ä¹°è…¿' if other_is_buy else 'å–è…¿')}å¹¶æš‚åœç­‰å¾…æ¢é’ˆ"
        )
        return self._result_failure(
            request,
            message,
            order_buy=other_order if other_is_buy else None,
            order_sell=other_order if not other_is_buy else None,
            partial_failure=True,
        )

    async def _handle_single_leg_shortfall(
        self,
        *,
        request: "ExecutionRequest",
        buy_order: OrderData,
        sell_order: OrderData,
        buy_adapter: ExchangeInterface,
        sell_adapter: ExchangeInterface,
        buy_symbol: str,
        sell_symbol: str,
        missing_buy: bool,
        shortfall: Decimal,
        target_quantity: Decimal,
        epsilon: Decimal,
        cancel_opposite_order: bool = False,
        result_quantity: Optional[Decimal] = None,
    ) -> "ExecutionResult":
        executor = self.executor
        Result = self.ExecutionResult

        fallback_exchange = request.exchange_buy if missing_buy else request.exchange_sell
        fallback_adapter = buy_adapter if missing_buy else sell_adapter
        fallback_symbol = buy_symbol if missing_buy else sell_symbol
        fallback_is_buy = missing_buy
        failing_order = buy_order if missing_buy else sell_order
        opposite_adapter = sell_adapter if missing_buy else buy_adapter
        opposite_symbol = sell_symbol if missing_buy else buy_symbol
        opposite_order = sell_order if missing_buy else buy_order
        reported_quantity = result_quantity or (target_quantity if not cancel_opposite_order else shortfall)

        leg_label = "ä¹°è…¿" if fallback_is_buy else "å–è…¿"
        completed_leg_label = "å–è…¿" if missing_buy else "ä¹°è…¿"

        logger.warning(
            f"âš ï¸ [å¥—åˆ©æ‰§è¡Œ] åŒé™ä»·æ¨¡å¼{'ä»…' if cancel_opposite_order else ''}"
            f"{completed_leg_label} å®Œæˆï¼Œ{leg_label} ç¼ºå£ {shortfall}ï¼Œ"
            f"å°†åœ¨ {fallback_exchange} å¯åŠ¨æ¿€è¿›é™ä»·è¡¥ä»“"
        )

        await executor._cancel_order(fallback_adapter, failing_order.id, fallback_symbol)
        if cancel_opposite_order:
            await executor._cancel_order(opposite_adapter, opposite_order.id, opposite_symbol)

        shortfall_dec = executor._to_decimal_value(shortfall)
        if shortfall_dec <= epsilon:
            return self._result_failure(
                request,
                "è¡¥å•æ•°é‡å¼‚å¸¸ï¼ˆ<=0ï¼‰ï¼Œå·²ç»ˆæ­¢æ‰§è¡Œ",
                order_buy=buy_order,
                order_sell=sell_order,
            )

        min_qty_limit = executor._resolve_min_order_qty(request, fallback_exchange)
        aggressive_allowed = shortfall_dec > epsilon
        if min_qty_limit and shortfall_dec < min_qty_limit:
            aggressive_allowed = False
            logger.info(
                f"â„¹ï¸ [å¥—åˆ©æ‰§è¡Œ] {fallback_exchange} {leg_label} è¡¥å•é‡ {shortfall_dec} < æœ€å°ä¸‹å•é‡ {min_qty_limit}ï¼Œè·³è¿‡æ¿€è¿›é™ä»·"
            )

        supplemental_filled = Decimal("0")
        remaining_to_fill = shortfall_dec
        final_fallback_order: Optional[OrderData] = None
        aggressive_order: Optional[OrderData] = None

        if aggressive_allowed:
            slippage_hint = executor._get_slippage_percent(request)
            logger.info(
                f"âš¡ [å¥—åˆ©æ‰§è¡Œ] {fallback_exchange} {leg_label} ç¼ºå£ {shortfall_dec}ï¼Œå°è¯•æ¿€è¿›é™ä»·è¡¥é½"
            )
            aggressive_order = await self._place_aggressive_limit_retry_order(
                adapter=fallback_adapter,
                symbol=fallback_symbol,
                quantity=remaining_to_fill,
                is_buy=fallback_is_buy,
                request=request,
                exchange_name=fallback_exchange,
                slippage_pct=slippage_hint,
                base_slippage=slippage_hint,
            )
            if aggressive_order:
                _, aggressive_filled = await self._confirm_market_fill_with_retries(
                    initial_order=aggressive_order,
                    adapter=fallback_adapter,
                    symbol=fallback_symbol,
                    quantity=remaining_to_fill,
                    is_buy=fallback_is_buy,
                    reduce_only=(not request.is_open),
                    request=request,
                    exchange_name=fallback_exchange,
                    allow_resubmit=False,
                    max_attempts=1,
                    enable_internal_aggressive_retry=False,
                )
                if aggressive_filled > epsilon:
                    supplemental_filled += aggressive_filled
                    remaining_to_fill = max(Decimal("0"), shortfall_dec - supplemental_filled)
                    final_fallback_order = aggressive_order

        if remaining_to_fill > epsilon:
            if aggressive_allowed and aggressive_order and getattr(aggressive_order, "id", None):
                try:
                    await executor._cancel_order(fallback_adapter, aggressive_order.id, fallback_symbol)
                except Exception as cancel_exc:
                    logger.warning(
                        "âš ï¸ [å¥—åˆ©æ‰§è¡Œ] å–æ¶ˆ %s æ¿€è¿›é™ä»·è¡¥å•å¤±è´¥ (order_id=%s): %s",
                        fallback_exchange,
                        aggressive_order.id,
                        cancel_exc,
                    )
                else:
                    logger.info(
                        "â†©ï¸ [å¥—åˆ©æ‰§è¡Œ] [%s] æ¿€è¿›é™ä»·è¡¥å•æœªå…¨æˆï¼Œå·²å…ˆå–æ¶ˆåŸå•ï¼ˆå‰©ä½™ %.6fï¼‰",
                        fallback_exchange,
                        float(remaining_to_fill),
                    )
                try:
                    latest = await fallback_adapter.get_order(str(aggressive_order.id), fallback_symbol)
                except Exception as refresh_exc:
                    logger.warning(
                        "âš ï¸ [å¥—åˆ©æ‰§è¡Œ] æŸ¥è¯¢ %s æ¿€è¿›é™ä»·è¡¥å•å‰©ä½™å¤±è´¥: %s",
                        fallback_exchange,
                        refresh_exc,
                    )
                else:
                    refreshed_remaining = executor._to_decimal_value(
                        getattr(latest, "remaining", None)
                    )
                    if refreshed_remaining is not None:
                        # REST åœ¨æ’¤å•åé€šå¸¸è¿”å› 0ï¼Œä½†æˆ‘ä»¬ä»ç„¶ä¿ç•™æœ¬åœ°å‰©ä½™ï¼Œé¿å…è¯¯ä»¥ä¸ºå·²è¡¥æ»¡
                        remaining_to_fill = max(
                            Decimal("0"),
                            refreshed_remaining,
                            remaining_to_fill,
                        )
            if remaining_to_fill <= epsilon:
                logger.info(
                    "âœ… [å¥—åˆ©æ‰§è¡Œ] %s %s æ¿€è¿›é™ä»·è¡¥å•å–æ¶ˆåå·²ç¡®è®¤æ— å‰©ä½™ï¼Œè·³è¿‡å¸‚ä»·è¡¥å•",
                    fallback_exchange,
                    leg_label,
                )
                final_fallback_order = aggressive_order or final_fallback_order
            else:
                if aggressive_allowed:
                    logger.warning(
                        f"âš ï¸ [å¥—åˆ©æ‰§è¡Œ] {fallback_exchange} {leg_label} æ¿€è¿›é™ä»·è¡¥å•æœªå®Œå…¨æˆäº¤ï¼Œå‰©ä½™ {remaining_to_fill} æ”¹ç”¨å¸‚ä»·è¡¥é½"
                    )
                else:
                    logger.warning(
                        f"âš ï¸ [å¥—åˆ©æ‰§è¡Œ] {fallback_exchange} {leg_label} è¡¥å•é‡ä¸è¶³æœ€å°é—¨æ§›æˆ–ç¦ç”¨æ¿€è¿›æ¨¡å¼ï¼Œç›´æ¥å¸‚ä»·è¡¥é½ {remaining_to_fill}"
                    )

                try:
                    market_order = await executor._place_market_order(
                        fallback_adapter,
                        fallback_symbol,
                        remaining_to_fill,
                        is_buy=fallback_is_buy,
                        reduce_only=(not request.is_open),
                        request=request,
                    )
                except self.ReduceOnlyRestrictionError:
                    completed_exchange = request.exchange_sell if missing_buy else request.exchange_buy
                    completed_adapter = sell_adapter if missing_buy else buy_adapter
                    completed_symbol = sell_symbol if missing_buy else buy_symbol
                    await executor.reduce_only_handler.handle_reduce_only_after_partial(
                        request=request,
                        completed_exchange=completed_exchange,
                        completed_adapter=completed_adapter,
                        completed_symbol=completed_symbol,
                        completed_quantity=shortfall,
                        completed_was_buy=(not missing_buy),
                        failing_exchange=fallback_exchange,
                        failing_symbol=fallback_symbol,
                        closing_issue=(not request.is_open),
                    )
                    return self._result_failure(
                        request,
                        f"{fallback_exchange} reduce-only é™åˆ¶ï¼Œå¸‚ä»·è¡¥é½è¢«æ‹’ç»",
                        order_buy=buy_order,
                        order_sell=sell_order,
                        partial_failure=True,
                        failed_exchange=fallback_exchange,
                        success_exchange=completed_exchange,
                        success_quantity=reported_quantity,
                    )

                if not market_order:
                    success_exchange = request.exchange_sell if missing_buy else request.exchange_buy
                    success_adapter = sell_adapter if missing_buy else buy_adapter
                    success_symbol = sell_symbol if missing_buy else buy_symbol
                    await executor._emergency_close_position(
                        exchange=success_exchange,
                        adapter=success_adapter,
                        symbol=success_symbol,
                        quantity=shortfall,
                        is_buy_to_close=missing_buy,
                        request=request,
                    )
                    return self._result_failure(
                        request,
                        "å¸‚ä»·è¡¥é½è®¢å•æäº¤å¤±è´¥ï¼Œå·²è§¦å‘ç´§æ€¥å¹³ä»“",
                        order_buy=buy_order,
                        order_sell=sell_order,
                        partial_failure=True,
                        failed_exchange=fallback_exchange,
                        success_exchange=success_exchange,
                        success_quantity=reported_quantity,
                    )

                market_order, market_filled = await self._confirm_market_fill_with_retries(
                    initial_order=market_order,
                    adapter=fallback_adapter,
                    symbol=fallback_symbol,
                    quantity=remaining_to_fill,
                    is_buy=fallback_is_buy,
                    reduce_only=(not request.is_open),
                    request=request,
                    exchange_name=fallback_exchange,
                    enable_internal_aggressive_retry=False,
                )
                if market_filled > epsilon:
                    supplemental_filled += market_filled
                    remaining_to_fill = max(Decimal("0"), shortfall_dec - supplemental_filled)
                    final_fallback_order = market_order

        if supplemental_filled + epsilon < shortfall_dec:
            success_exchange = request.exchange_sell if missing_buy else request.exchange_buy
            success_adapter = sell_adapter if missing_buy else buy_adapter
            success_symbol = sell_symbol if missing_buy else buy_symbol
            await executor._emergency_close_position(
                exchange=success_exchange,
                adapter=success_adapter,
                symbol=success_symbol,
                quantity=shortfall_dec - supplemental_filled,
                is_buy_to_close=missing_buy,
                request=request,
            )
            return self._result_failure(
                request,
                "è¡¥å•æˆäº¤é‡ä¸è¶³ç›®æ ‡ï¼Œå·²è§¦å‘ç´§æ€¥å¹³ä»“",
                order_buy=buy_order,
                order_sell=sell_order,
                partial_failure=True,
                failed_exchange=fallback_exchange,
                success_exchange=success_exchange,
                success_quantity=reported_quantity,
            )

        # ğŸ”¥ è·å–æœªè¡¥é½è…¿çš„åŸå§‹éƒ¨åˆ†æˆäº¤æ•°é‡
        failing_order_partial_filled = executor._to_decimal_value(
            getattr(failing_order, "filled", Decimal("0"))
        )
        
        # ğŸ”¥ è·å–å¯¹é¢è…¿ï¼ˆå·²å®Œæˆï¼‰çš„æˆäº¤æ•°é‡
        opposite_filled = executor._to_decimal_value(
            getattr(opposite_order, "filled", Decimal("0"))
        )
        
        # ğŸ”¥ è¯¥è…¿æ€»æˆäº¤ = åŸå§‹è®¢å•éƒ¨åˆ†æˆäº¤ + è¡¥å•ç´¯è®¡æˆäº¤
        total_failing_leg_filled = failing_order_partial_filled + supplemental_filled
        
        # ğŸ”¥ è°ƒè¯•æ—¥å¿—ï¼šè®°å½•æˆäº¤æ˜ç»†
        logger.info(
            f"ğŸ“Š [æˆäº¤æ˜ç»†] {fallback_exchange} | "
            f"é™ä»·éƒ¨åˆ†æˆäº¤={failing_order_partial_filled} + è¡¥å•åˆè®¡={supplemental_filled} = æ€»æˆäº¤={total_failing_leg_filled} | "
            f"å¯¹é¢è…¿æˆäº¤={opposite_filled} | "
            f"è®¡ç®—æ•°é‡=min({total_failing_leg_filled}, {opposite_filled}) | "
            f"ç¼ºå£ç›®æ ‡={shortfall}"
        )
        
        if not final_fallback_order:
            final_fallback_order = failing_order
        
        final_buy_order = final_fallback_order if missing_buy else buy_order
        final_sell_order = sell_order if missing_buy else final_fallback_order
        
        # ğŸ”¥ æ›´æ–°æœ€ç»ˆè®¢å•å¯¹è±¡çš„ filled å­—æ®µä¸ºæ€»æˆäº¤æ•°
        if final_fallback_order:
            final_fallback_order.filled = total_failing_leg_filled
        
        executor._log_execution_summary(
            request=request,
            order_buy=final_buy_order,
            order_sell=final_sell_order,
            is_open=request.is_open,
            is_last_split=request.is_last_split,
        )
        
        # ğŸ”¥ æ­£ç¡®è®¡ç®—æˆäº¤æ•°é‡ï¼šä¸¤è…¿å–æœ€å°å€¼
        actual_quantity = min(opposite_filled, total_failing_leg_filled)

        return Result(
            success=True,
            order_buy=final_buy_order,
            order_sell=final_sell_order,
            success_quantity=actual_quantity,
        )

    async def _fill_leg_to_target(
        self,
        *,
        adapter: ExchangeInterface,
        symbol: str,
        exchange_name: str,
        is_buy: bool,
        remaining_quantity: Decimal,
        request: "ExecutionRequest",
        epsilon: Decimal,
    ) -> Decimal:
        """
        ä½¿ç”¨æ¿€è¿›é™ä»· + å¸‚ä»·é¡ºåºè¡¥é½å•ä¸ªè…¿è‡³æ‹†å•ç›®æ ‡æ•°é‡ã€‚
        """
        executor = self.executor
        leg_label = "ä¹°è…¿" if is_buy else "å–è…¿"
        target_quantity = executor._to_decimal_value(remaining_quantity)
        if target_quantity <= epsilon:
            return Decimal("0")

        min_qty_limit = executor._resolve_min_order_qty(request, exchange_name)
        aggressive_allowed = target_quantity > epsilon
        if min_qty_limit and target_quantity < min_qty_limit:
            aggressive_allowed = False
            logger.info(
                f"â„¹ï¸ [å¥—åˆ©æ‰§è¡Œ] {exchange_name} remaining={target_quantity} < æœ€å°ä¸‹å•é‡ {min_qty_limit}ï¼Œè·³è¿‡æ¿€è¿›é™ä»·è¡¥é½"
            )

        supplemental_filled = Decimal("0")
        remaining_to_fill = target_quantity

        if aggressive_allowed:
            slippage_hint = executor._get_slippage_percent(request)
            logger.info(
                f"âš¡ [å¥—åˆ©æ‰§è¡Œ] {exchange_name} {leg_label} å‰©ä½™ {remaining_to_fill}ï¼Œä¼˜å…ˆå°è¯•æ¿€è¿›é™ä»·è¡¥é½"
            )
            aggressive_order = await self._place_aggressive_limit_retry_order(
                adapter=adapter,
                symbol=symbol,
                quantity=remaining_to_fill,
                is_buy=is_buy,
                request=request,
                exchange_name=exchange_name,
                slippage_pct=slippage_hint,
                base_slippage=slippage_hint,
            )
            if aggressive_order:
                _, aggressive_filled = await self._confirm_market_fill_with_retries(
                    initial_order=aggressive_order,
                    adapter=adapter,
                    symbol=symbol,
                    quantity=remaining_to_fill,
                    is_buy=is_buy,
                    reduce_only=(not request.is_open),
                    request=request,
                    exchange_name=exchange_name,
                    allow_resubmit=False,
                    max_attempts=1,
                    enable_internal_aggressive_retry=False,
                )
                if aggressive_filled > epsilon:
                    supplemental_filled += aggressive_filled
                    remaining_to_fill = max(Decimal("0"), target_quantity - supplemental_filled)

        if remaining_to_fill > epsilon:
            if aggressive_allowed:
                logger.warning(
                    "âš ï¸ [å¥—åˆ©æ‰§è¡Œ] %s %s æ¿€è¿›é™ä»·è¡¥å•æœªå®Œå…¨æˆäº¤ï¼Œæ”¹ç”¨å¸‚ä»·è¡¥å• (remaining=%s)",
                    exchange_name,
                    leg_label,
                    remaining_to_fill,
                )
            else:
                logger.warning(
                    "âš ï¸ [å¥—åˆ©æ‰§è¡Œ] %s %s å‰©ä½™é‡ä¸è¶³æœ€å°é™é¢ï¼Œç›´æ¥ä½¿ç”¨å¸‚ä»·è¡¥å• (remaining=%s)",
                    exchange_name,
                    leg_label,
                    remaining_to_fill,
                )

            try:
                market_order = await executor._place_market_order(
                    adapter,
                    symbol,
                    remaining_to_fill,
                    is_buy=is_buy,
                    reduce_only=(not request.is_open),
                    request=request,
                )
            except self.ReduceOnlyRestrictionError:
                logger.warning(
                    f"âš ï¸ [å¥—åˆ©æ‰§è¡Œ] {exchange_name} {leg_label} å¸‚ä»·è¡¥å•è§¦å‘ reduce-only é™åˆ¶ï¼Œremaining={remaining_to_fill}"
                )
                raise

            if not market_order:
                raise RuntimeError(
                    f"{exchange_name} {leg_label} å¸‚ä»·è¡¥å•æäº¤å¤±è´¥ï¼Œæ— æ³•è¡¥é½å‰©ä½™ {remaining_to_fill}"
                )

            market_order, market_filled = await self._confirm_market_fill_with_retries(
                initial_order=market_order,
                adapter=adapter,
                symbol=symbol,
                quantity=remaining_to_fill,
                is_buy=is_buy,
                reduce_only=(not request.is_open),
                request=request,
                exchange_name=exchange_name,
                enable_internal_aggressive_retry=False,
            )
            if market_filled > epsilon:
                supplemental_filled += market_filled
                remaining_to_fill = max(Decimal("0"), target_quantity - supplemental_filled)

        if supplemental_filled + epsilon < target_quantity:
            raise RuntimeError(
                f"{exchange_name} {leg_label} æ¿€è¿›é™ä»·/å¸‚ä»·è¡¥å•ä»æœªæˆäº¤ï¼Œå‰©ä½™ {remaining_to_fill}"
            )

        return supplemental_filled
    def _calculate_success_quantity_from_orders(
        self,
        order_buy: Optional[OrderData],
        order_sell: Optional[OrderData],
        fallback: Optional[Decimal] = None,
    ) -> Decimal:
        """ä»ä¹°å–è®¢å•ä¸­è®¡ç®—å®é™…æˆäº¤æ•°é‡ï¼ˆå–ä¸¤è…¿æœ€å°å€¼ï¼‰"""
        executor = self.executor
        quantities: List[Decimal] = []
        if order_buy and getattr(order_buy, "filled", None) is not None:
            buy_qty = executor._to_decimal_value(order_buy.filled or Decimal("0"))
            if buy_qty > Decimal("0"):
                quantities.append(buy_qty)
        if order_sell and getattr(order_sell, "filled", None) is not None:
            sell_qty = executor._to_decimal_value(order_sell.filled or Decimal("0"))
            if sell_qty > Decimal("0"):
                quantities.append(sell_qty)
        if len(quantities) == 2:
            return min(quantities)
        if len(quantities) == 1:
            return quantities[0]
        return executor._to_decimal_value(fallback or Decimal("0"))

    async def _resolve_filled_quantity(
        self,
        *,
        order: OrderData,
        adapter: ExchangeInterface,
        symbol: str,
        reported_filled: Optional[Decimal],
    ) -> Decimal:
        """
        ç¡®è®¤é™ä»·è®¢å•çš„çœŸå®æˆäº¤æ•°é‡ï¼Œæ”¯æŒéƒ¨åˆ†æˆäº¤åœºæ™¯ã€‚
        ä¼˜å…ˆä½¿ç”¨ç­‰å¾…é˜¶æ®µè¿”å›çš„æ•°é‡ï¼›è‹¥æ— ï¼Œåˆ™å°è¯•è¯»å– order.filledï¼Œ
        ä»ä¸ºç©ºæ—¶è§¦å‘ä¸€æ¬¡ REST æŸ¥è¯¢åˆ·æ–°çŠ¶æ€ã€‚
        """
        executor = self.executor
        decimal_value = executor._to_decimal_value(reported_filled or Decimal("0"))
        if decimal_value > Decimal("0"):
            return decimal_value

        if order and getattr(order, "filled", None):
            existing = executor._to_decimal_value(order.filled or Decimal("0"))
            if existing > Decimal("0"):
                return existing

        if not adapter or not hasattr(adapter, "get_order"):
            return Decimal("0")

        try:
            latest = await adapter.get_order(str(order.id), symbol)
        except Exception as exc:  # pragma: no cover - ä»…æ—¥å¿—æç¤º
            logger.warning(
                "âš ï¸ [å¥—åˆ©æ‰§è¡Œ] æŸ¥è¯¢ %s è®¢å• %s çŠ¶æ€å¤±è´¥: %s",
                executor._get_exchange_name(adapter),
                order.id,
                exc,
            )
            return Decimal("0")

        if not latest:
            return Decimal("0")

        try:
            executor.order_monitor._merge_order_state(order, latest)  # type: ignore[attr-defined]
        except AttributeError:
            order.filled = latest.filled or order.filled
            if latest.status:
                order.status = latest.status
            if latest.average:
                order.average = latest.average
            if latest.price:
                order.price = latest.price
            if latest.remaining is not None:
                order.remaining = latest.remaining

        refreshed = executor._to_decimal_value(order.filled or Decimal("0"))
        if refreshed > Decimal("0"):
            logger.info(
                "â„¹ï¸ [å¥—åˆ©æ‰§è¡Œ] åˆ·æ–°æˆäº¤æ•°é‡: %s %s -> %s",
                executor._get_exchange_name(adapter),
                order.id,
                refreshed,
            )
        return refreshed

